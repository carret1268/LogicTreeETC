diff --git a/.github/dependabot.yml b/.github/dependabot.yml
new file mode 100644
index 0000000..605600a
--- /dev/null
+++ b/.github/dependabot.yml
@@ -0,0 +1,10 @@
+version: 2
+updates:
+  - package-ecosystem: "pip"
+    directory: "/"
+    schedule:
+      interval: "weekly"  # can be "daily", "weekly", or "monthly"
+  - package-ecosystem: "github-actions"
+    directory: "/"
+    schedule:
+      interval: "weekly"
diff --git a/.github/workflows/cd.yml b/.github/workflows/cd.yml
new file mode 100644
index 0000000..88b1f9d
--- /dev/null
+++ b/.github/workflows/cd.yml
@@ -0,0 +1,31 @@
+name: CD
+
+on:
+  push:
+    tags:
+      - "v*.*.*"
+
+jobs:
+  release:
+    runs-on: ubuntu-latest
+    steps:
+    - name: Checkout code
+      uses: actions/checkout@v4
+
+    - name: Set up Python
+      uses: actions/setup-python@v5
+      with:
+        python-version: "3.11"
+
+    - name: Install build tools
+      run: |
+        python -m pip install --upgrade pip build twine
+
+    - name: Build distribution
+      run: python -m build
+
+    - name: Publish to PyPI
+      env:
+        TWINE_USERNAME: __token__
+        TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
+      run: twine upload dist/*
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
new file mode 100644
index 0000000..9d2d27e
--- /dev/null
+++ b/.github/workflows/ci.yml
@@ -0,0 +1,76 @@
+name: CI
+
+on:
+  push:
+    branches:
+      - '**'
+  pull_request:
+    branches:
+      - main
+
+jobs:
+  build_package-unit_test-build_docs:
+    runs-on: ubuntu-latest
+    strategy:
+      matrix:
+        python-version: ["3.10", "3.11", "3.12"]
+
+    steps:
+    - name: Checkout code
+      uses: actions/checkout@v4
+      with:
+        fetch-depth: 2
+
+    - name: Set up Python
+      uses: actions/setup-python@v5
+      with:
+        python-version: ${{ matrix.python-version }}
+
+    - name: Install project dependencies
+      run: |
+        python -m pip install --upgrade pip
+        pip install -e .
+        pip install pytest coverage ruff mypy bandit
+        pip install -r docs/requirements.txt
+
+    - name: Install minimal LaTeX packages
+      run: |
+        sudo apt-get update
+        sudo apt-get install -y \
+          texlive-latex-base \
+          texlive-latex-recommended \
+          texlive-fonts-recommended \
+          texlive-latex-extra \
+          texlive-humanities \
+          dvipng \
+          cm-super
+
+    - name: Run linter (Ruff)
+      run: ruff check .
+
+    - name: Check formatting (Ruff)
+      run: ruff format --check .
+
+    - name: Run static typechecker (Mypy)
+      run: mypy logictree/
+
+    - name: Run security check (Bandit)
+      run: bandit -r logictree
+
+    - name: Run tests with coverage
+      run: |
+        coverage run --branch -m pytest
+        coverage xml  # generates coverage.xml for codecov upload
+
+    - name: Upload coverage to Codecov
+      uses: codecov/codecov-action@v5
+      with:
+        token: ${{ secrets.CODECOV_TOKEN }}
+
+    - name: Check version consistency
+      run: bash scripts/check_version_and_build_docs.sh
+
+    - name: Build documentation
+      run: |
+        cd docs
+        make html
diff --git a/.gitignore b/.gitignore
index 0916873..e65cd8d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,4 +2,10 @@ logictree/__pycache__/
 dist/
 build/
 *.egg-info/
-docs/_build/
\ No newline at end of file
+docs/_build/
+.mypy_cache/
+.ruff_cache/
+.pytest_cache/
+.coverage
+tests/__pycache__
+examples/test.py
\ No newline at end of file
diff --git a/README.md b/README.md
index 733f231..c71ddbf 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,7 @@
 # LogicTreeETC
 
 [![Documentation Status](https://readthedocs.org/projects/logictreeetc/badge/?version=latest)](https://logictreeetc.readthedocs.io/en/latest/?badge=latest)
+[![codecov](https://codecov.io/gh/carret1268/logictreeetc/branch/main/graph/badge.svg)](https://codecov.io/gh/carret1268/logictreeetc)
 
 **Create flexible, publication-quality logic tree diagrams and multi-segment arrows with full vertex control in Python.**
 
diff --git a/docs/conf.py b/docs/conf.py
index 4bfbb10..faea1c0 100644
--- a/docs/conf.py
+++ b/docs/conf.py
@@ -1,6 +1,7 @@
 import os
 import sys
-sys.path.insert(0, os.path.abspath('..'))
+
+sys.path.insert(0, os.path.abspath(".."))
 
 # Configuration file for the Sphinx documentation builder.
 #
@@ -10,28 +11,27 @@ sys.path.insert(0, os.path.abspath('..'))
 # -- Project information -----------------------------------------------------
 # https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information
 
-project = 'LogicTreeETC'
-copyright = '2025, E. Tyler Carr'
-author = 'E. Tyler Carr'
-release = '0.1.0'
+project = "LogicTreeETC"
+copyright = "2025, E. Tyler Carr"
+author = "E. Tyler Carr"
+release = "0.1.0"
 
 # -- General configuration ---------------------------------------------------
 # https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration
 
 extensions = [
-    'sphinx.ext.autodoc',
-    'sphinx.ext.napoleon',
-    'sphinx_autodoc_typehints',
-    'myst_parser',
-    ]
-
-templates_path = ['_templates']
-exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']
+    "sphinx.ext.autodoc",
+    "sphinx.ext.napoleon",
+    "sphinx_autodoc_typehints",
+    "myst_parser",
+]
 
+templates_path = ["_templates"]
+exclude_patterns = ["_build", "Thumbs.db", ".DS_Store"]
 
 
 # -- Options for HTML output -------------------------------------------------
 # https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output
 
 html_theme = "furo"
-html_static_path = ['_static']
+html_static_path = ["_static"]
diff --git a/docs/index.md b/docs/index.md
index f155a03..fba2d81 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -1,5 +1,8 @@
 # LogicTreeETC
 
+[![Documentation Status](https://readthedocs.org/projects/logictreeetc/badge/?version=latest)](https://logictreeetc.readthedocs.io/en/latest/?badge=latest)
+[![codecov](https://codecov.io/gh/carret1268/logictreeetc/branch/main/graph/badge.svg)](https://codecov.io/gh/carret1268/logictreeetc)
+
 **Create flexible, publication-quality logic tree diagrams and multi-segment arrows with full vertex control in Python.**
 
 LogicTreeETC lets you create logic trees by combining labeled boxes and arrows with precise control over geometry, fonts, styling, and LaTeX-rendered annotations.
diff --git a/docs/logictree.rst b/docs/logictree.rst
index baad7dd..96abed9 100644
--- a/docs/logictree.rst
+++ b/docs/logictree.rst
@@ -4,14 +4,6 @@ logictree package
 Submodules
 ----------
 
-logictree.ArrowETC module
--------------------------
-
-.. automodule:: logictree.ArrowETC
-   :members:
-   :show-inheritance:
-   :undoc-members:
-
 logictree.LogicBoxETC module
 ----------------------------
 
diff --git a/examples/arrows/arrowExample.py b/examples/arrows/arrowExample.py
deleted file mode 100644
index a9fb476..0000000
--- a/examples/arrows/arrowExample.py
+++ /dev/null
@@ -1,69 +0,0 @@
-"""
-Example ArrowETC Arrows: Multi-Segment Arrow Shapes
-
-This example demonstrates the ArrowETC class by generating individual PNGs of arrows
-with different paths, including single-segment, multi-segment, straight, and jointed arrows.
-Each arrow is saved as a separate PNG file, showcasing the flexibility of ArrowETC for
-creating arrows with arbitrary segments and orientations.
-
-It shows:
-- Creating straight arrows pointing in different directions (up, left, diagonal).
-- Building arrows with one or multiple right-angle joints.
-- Saving arrow shapes as PNGs with clear visualization of the arrow shaft and head.
-- Using ArrowETC with minimal setup to generate complex arrows.
-- Creating segmented rectangles (arrows with no head).
-
-This script produces six PNG images illustrating different arrow styles.
-
-Usage:
-------
-Run this script directly. It will save:
-- up_arrow.png
-- left_arrow.png
-- right_down_arrow.png
-- single_joint_arrow.png
-- multi_joint_arrow-acute.png
-- multi_joint_arrow-obtuse.png
-- multi_joint_rect.png
-in the same directory as this script.
-
-Dependencies:
--------------
-- Python packages: matplotlib, numpy, your installed logictree package.
-"""
-from pathlib import Path
-import sys
-import os
-
-# Compute absolute path to the parent directory of examples/
-project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../..'))
-if project_root not in sys.path:
-    sys.path.insert(0, project_root)
-
-from logictree.ArrowETC import ArrowETC
-
-def main():
-    arrow = ArrowETC([(0, 0), (0, 10)], 2, True)
-    arrow.save_arrow(name=Path(__file__).resolve().parent / "up_arrow.png")
-
-    arrow = ArrowETC([(0, 0), (-10, 0)], 2, True)
-    arrow.save_arrow(name=Path(__file__).resolve().parent / "left_arrow.png")
-
-    arrow = ArrowETC([(0, 0), (10, -8)], 2, True)
-    arrow.save_arrow(name=Path(__file__).resolve().parent / "right_down_arrow.png")
-
-    arrow = ArrowETC([(0, 0), (-10, 0), (-10, -10)], 2, True)
-    arrow.save_arrow(name=Path(__file__).resolve().parent / "single_joint_arrow.png")
-
-    arrow = ArrowETC([(0, 0), (-10, 0), (-10, -10), (-2, -5)], 2, True)
-    arrow.save_arrow(name=Path(__file__).resolve().parent / "multi_joint_arrow-acute.png")
-
-    arrow = ArrowETC([(0, 0), (-10, 0), (-10, -10), (-2, -15)], 2, True)
-    arrow.save_arrow(name=Path(__file__).resolve().parent / "multi_joint_arrow-obtuse.png")
-
-    arrow = ArrowETC([(0, 0), (-10, 0), (-10, -10), (-2, -15)], 2, False)
-    arrow.save_arrow(name=Path(__file__).resolve().parent / "multi_joint_rect.png")
-
-
-if __name__ == "__main__":
-    main()
diff --git a/examples/arrows/left_arrow.png b/examples/arrows/left_arrow.png
deleted file mode 100644
index 1621844..0000000
Binary files a/examples/arrows/left_arrow.png and /dev/null differ
diff --git a/examples/arrows/multi_joint_arrow-acute.png b/examples/arrows/multi_joint_arrow-acute.png
deleted file mode 100644
index fdfe831..0000000
Binary files a/examples/arrows/multi_joint_arrow-acute.png and /dev/null differ
diff --git a/examples/arrows/multi_joint_arrow-obtuse.png b/examples/arrows/multi_joint_arrow-obtuse.png
deleted file mode 100644
index ee7c301..0000000
Binary files a/examples/arrows/multi_joint_arrow-obtuse.png and /dev/null differ
diff --git a/examples/arrows/multi_joint_rect.png b/examples/arrows/multi_joint_rect.png
deleted file mode 100644
index c4df7e8..0000000
Binary files a/examples/arrows/multi_joint_rect.png and /dev/null differ
diff --git a/examples/arrows/right_down_arrow.png b/examples/arrows/right_down_arrow.png
deleted file mode 100644
index e9e3a23..0000000
Binary files a/examples/arrows/right_down_arrow.png and /dev/null differ
diff --git a/examples/arrows/single_joint_arrow.png b/examples/arrows/single_joint_arrow.png
deleted file mode 100644
index 9f33e8c..0000000
Binary files a/examples/arrows/single_joint_arrow.png and /dev/null differ
diff --git a/examples/arrows/up_arrow.png b/examples/arrows/up_arrow.png
deleted file mode 100644
index f988a14..0000000
Binary files a/examples/arrows/up_arrow.png and /dev/null differ
diff --git a/examples/decisionTreeDSAExample.py b/examples/decisionTreeDSAExample.py
index 459ebc7..bad14d7 100644
--- a/examples/decisionTreeDSAExample.py
+++ b/examples/decisionTreeDSAExample.py
@@ -24,15 +24,17 @@ Dependencies:
 -------------
 - Python packages: matplotlib, your installed logictree package.
 """
+
 from pathlib import Path
 import sys
 import os
 
-project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
+project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
 if project_root not in sys.path:
     sys.path.insert(0, project_root)
 
-from logictree.LogicTreeETC import LogicTree
+from logictree import LogicTree  # noqa: E402
+
 
 def make_ds_algo_study_order_tree():
     y_row1, y_row2, y_row3 = 85, 20, -40
@@ -41,40 +43,152 @@ def make_ds_algo_study_order_tree():
     xlims = (-30, 140)
     ylims = (-60, 110)
 
-    logic_tree = LogicTree(xlims=xlims, ylims=ylims, title='Suggested Study Order: DSA')
+    logic_tree = LogicTree(xlims=xlims, ylims=ylims, title="Suggested Study Order: DSA")
 
     # Top row sequence: Arrays -> Stacks -> Queues -> Singly Linked Lists
-    logic_tree.add_box(xpos=0, ypos=y_row1, text="Arrays", box_name="Arrays", bbox_fc='black', bbox_ec='xkcd:lime green')
-    logic_tree.add_box(xpos=30, ypos=y_row1, text="Stacks", box_name="Stacks", bbox_fc='black', bbox_ec='xkcd:teal')
-    logic_tree.add_box(xpos=60, ypos=y_row1, text="Queues", box_name="Queues", bbox_fc='black', bbox_ec='xkcd:sky blue')
-    logic_tree.add_box(xpos=90, ypos=y_row1, text="Singly Linked Lists", box_name="SinglyLinked", bbox_fc='black', bbox_ec='xkcd:purple', ha='left')
+    logic_tree.add_box(
+        xpos=0,
+        ypos=y_row1,
+        text="Arrays",
+        box_name="Arrays",
+        bbox_fc="black",
+        bbox_ec="xkcd:lime green",
+    )
+    logic_tree.add_box(
+        xpos=30,
+        ypos=y_row1,
+        text="Stacks",
+        box_name="Stacks",
+        bbox_fc="black",
+        bbox_ec="xkcd:teal",
+    )
+    logic_tree.add_box(
+        xpos=60,
+        ypos=y_row1,
+        text="Queues",
+        box_name="Queues",
+        bbox_fc="black",
+        bbox_ec="xkcd:sky blue",
+    )
+    logic_tree.add_box(
+        xpos=90,
+        ypos=y_row1,
+        text="Singly Linked Lists",
+        box_name="SinglyLinked",
+        bbox_fc="black",
+        bbox_ec="xkcd:purple",
+        ha="left",
+    )
 
     # Second row: Circular Linked Lists -> Doubly Linked Lists
-    logic_tree.add_box(xpos=-5, ypos=y_row2, text="Circular Linked Lists", box_name="CircularLinked", bbox_fc='black', bbox_ec='xkcd:lavender', ha='left')
-    logic_tree.add_box(xpos=120, ypos=y_row2, text="Doubly Linked Lists", box_name="DoublyLinked", bbox_fc='black', bbox_ec='xkcd:violet')
+    logic_tree.add_box(
+        xpos=-5,
+        ypos=y_row2,
+        text="Circular Linked Lists",
+        box_name="CircularLinked",
+        bbox_fc="black",
+        bbox_ec="xkcd:lavender",
+        ha="left",
+    )
+    logic_tree.add_box(
+        xpos=120,
+        ypos=y_row2,
+        text="Doubly Linked Lists",
+        box_name="DoublyLinked",
+        bbox_fc="black",
+        bbox_ec="xkcd:violet",
+    )
 
     # Third row: Trees and Graphs
-    logic_tree.add_box(xpos=122.15, ypos=y_row3, text="Trees (BST, AVL, etc.)", box_name="Trees", bbox_fc='black', bbox_ec='xkcd:goldenrod')
-    logic_tree.add_box(xpos=20, ypos=y_row3, text="Graph Algorithms", box_name="Graphs", bbox_fc='black', bbox_ec='xkcd:red orange')
+    logic_tree.add_box(
+        xpos=122.15,
+        ypos=y_row3,
+        text="Trees (BST, AVL, etc.)",
+        box_name="Trees",
+        bbox_fc="black",
+        bbox_ec="xkcd:goldenrod",
+    )
+    logic_tree.add_box(
+        xpos=20,
+        ypos=y_row3,
+        text="Graph Algorithms",
+        box_name="Graphs",
+        bbox_fc="black",
+        bbox_ec="xkcd:red orange",
+    )
 
     # Connect boxes in suggested order:
-    logic_tree.add_connection(boxA=logic_tree.boxes['Arrays'], boxB=logic_tree.boxes['Stacks'],
-                              arrow_head=True, arrow_width=arr_width, tip_offset=tip_offset, fc=(1,1,1,0.3), ec="white")
-    logic_tree.add_connection(boxA=logic_tree.boxes['Stacks'], boxB=logic_tree.boxes['Queues'],
-                              arrow_head=True, arrow_width=arr_width, tip_offset=tip_offset, fc=(1,1,1,0.3), ec="white")
-    logic_tree.add_connection(boxA=logic_tree.boxes['Queues'], boxB=logic_tree.boxes['SinglyLinked'],
-                              arrow_head=True, arrow_width=arr_width, tip_offset=tip_offset, fc=(1,1,1,0.3), ec="white")
-    logic_tree.add_connection(boxA=logic_tree.boxes['SinglyLinked'], boxB=logic_tree.boxes['CircularLinked'],
-                              arrow_head=True, arrow_width=arr_width, tip_offset=tip_offset, fc=(1,1,1,0.3), ec="white")
-    logic_tree.add_connection(boxA=logic_tree.boxes['CircularLinked'], boxB=logic_tree.boxes['DoublyLinked'],
-                              arrow_head=True, arrow_width=arr_width, tip_offset=tip_offset, fc=(1,1,1,0.3), ec="white")
-    logic_tree.add_connection(boxA=logic_tree.boxes['DoublyLinked'], boxB=logic_tree.boxes['Trees'],
-                              arrow_head=True, arrow_width=arr_width, tip_offset=tip_offset, fc=(1,1,1,0.3), ec="white")
-    logic_tree.add_connection(boxA=logic_tree.boxes['Trees'], boxB=logic_tree.boxes['Graphs'],
-                              arrow_head=True, arrow_width=arr_width, tip_offset=tip_offset, fc=(1,1,1,0.3), ec="white")
-
-    logic_tree.make_title(pos='center')
-    logic_tree.save_as_png(file_name=Path(__file__).resolve().parent / 'DecisionTree_DSA-Example.png', dpi=600, content_padding=0.1)
-
-if __name__ == '__main__':
+    logic_tree.add_connection(
+        boxA=logic_tree.boxes["Arrays"],
+        boxB=logic_tree.boxes["Stacks"],
+        arrow_head=True,
+        arrow_width=arr_width,
+        tip_offset=tip_offset,
+        fc=(1, 1, 1, 0.3),
+        ec="white",
+    )
+    logic_tree.add_connection(
+        boxA=logic_tree.boxes["Stacks"],
+        boxB=logic_tree.boxes["Queues"],
+        arrow_head=True,
+        arrow_width=arr_width,
+        tip_offset=tip_offset,
+        fc=(1, 1, 1, 0.3),
+        ec="white",
+    )
+    logic_tree.add_connection(
+        boxA=logic_tree.boxes["Queues"],
+        boxB=logic_tree.boxes["SinglyLinked"],
+        arrow_head=True,
+        arrow_width=arr_width,
+        tip_offset=tip_offset,
+        fc=(1, 1, 1, 0.3),
+        ec="white",
+    )
+    logic_tree.add_connection(
+        boxA=logic_tree.boxes["SinglyLinked"],
+        boxB=logic_tree.boxes["CircularLinked"],
+        arrow_head=True,
+        arrow_width=arr_width,
+        tip_offset=tip_offset,
+        fc=(1, 1, 1, 0.3),
+        ec="white",
+    )
+    logic_tree.add_connection(
+        boxA=logic_tree.boxes["CircularLinked"],
+        boxB=logic_tree.boxes["DoublyLinked"],
+        arrow_head=True,
+        arrow_width=arr_width,
+        tip_offset=tip_offset,
+        fc=(1, 1, 1, 0.3),
+        ec="white",
+    )
+    logic_tree.add_connection(
+        boxA=logic_tree.boxes["DoublyLinked"],
+        boxB=logic_tree.boxes["Trees"],
+        arrow_head=True,
+        arrow_width=arr_width,
+        tip_offset=tip_offset,
+        fc=(1, 1, 1, 0.3),
+        ec="white",
+    )
+    logic_tree.add_connection(
+        boxA=logic_tree.boxes["Trees"],
+        boxB=logic_tree.boxes["Graphs"],
+        arrow_head=True,
+        arrow_width=arr_width,
+        tip_offset=tip_offset,
+        fc=(1, 1, 1, 0.3),
+        ec="white",
+    )
+
+    logic_tree.make_title(pos="center")
+    logic_tree.save_as_png(
+        file_name=Path(__file__).resolve().parent / "DecisionTree_DSA-Example.png",
+        dpi=600,
+        content_padding=0.1,
+    )
+
+
+if __name__ == "__main__":
     make_ds_algo_study_order_tree()
diff --git a/examples/decisionTreeNTAExample.py b/examples/decisionTreeNTAExample.py
index 4ac0f37..080d63f 100644
--- a/examples/decisionTreeNTAExample.py
+++ b/examples/decisionTreeNTAExample.py
@@ -22,59 +22,63 @@ Dependencies:
 - logic_tree_data.csv: CSV containing the counts and threshold parameters.
 - Python packages: matplotlib, pandas, your installed logictree package.
 """
+
 from pathlib import Path
 import sys
 import os
 
+from matplotlib.patches import BoxStyle
+import pandas as pd
+
 # Compute absolute path to the parent directory of examples/
-project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
+project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
 if project_root not in sys.path:
     sys.path.insert(0, project_root)
 
-from matplotlib.patches import BoxStyle
-import pandas as pd
+from logictree import LogicTree  # noqa: E402
 
-from logictree.LogicTreeETC import LogicTree
 
 def make_tree():
     # Load CSV with counts and thresholds
-    df = pd.read_csv(f'{Path(__file__).resolve().parent}/logic_tree_data.csv')
+    df = pd.read_csv(f"{Path(__file__).resolve().parent}/logic_tree_data.csv")
 
     # Build text for first row (total/missing samples)
-    n_total_sample_occurence = df['n_total_sample_occurence'].iloc[0]
-    str_total_sample_occurence = f'Total Sample Occurence (N = {n_total_sample_occurence:,})'
-    n_missing_occurence = df['n_missing_occurence'].iloc[0]
-    str_missing_occurence = f'Missing (N = {n_missing_occurence:,})'
+    n_total_sample_occurence = df["n_total_sample_occurence"].iloc[0]
+    str_total_sample_occurence = (
+        f"Total Sample Occurence (N = {n_total_sample_occurence:,})"
+    )
+    n_missing_occurence = df["n_missing_occurence"].iloc[0]
+    str_missing_occurence = f"Missing (N = {n_missing_occurence:,})"
 
     # Build text for replicate threshold results
-    n_over_replicate = df['n_over_replicate'].iloc[0]
-    str_over_replicate = f'$\\geq$ Replicate Threshold (N = {n_over_replicate:,})'
-    n_under_replicate = df['n_under_replicate'].iloc[0]
-    str_under_replicate = f'$<$ Replicate Threshold (N = {n_under_replicate:,})'
+    n_over_replicate = df["n_over_replicate"].iloc[0]
+    str_over_replicate = f"$\\geq$ Replicate Threshold (N = {n_over_replicate:,})"
+    n_under_replicate = df["n_under_replicate"].iloc[0]
+    str_under_replicate = f"$<$ Replicate Threshold (N = {n_under_replicate:,})"
 
     # Build text for CV threshold results
-    n_under_CV = df['n_under_CV'].iloc[0]
-    str_under_CV = f'$\\leq$ CV Threshold (N = {n_under_CV:,})'
-    n_over_CV = df['n_over_CV'].iloc[0]
-    str_over_CV = f'$>$ CV Threshold (N = {n_over_CV:,})'
+    n_under_CV = df["n_under_CV"].iloc[0]
+    str_under_CV = f"$\\leq$ CV Threshold (N = {n_under_CV:,})"
+    n_over_CV = df["n_over_CV"].iloc[0]
+    str_over_CV = f"$>$ CV Threshold (N = {n_over_CV:,})"
 
     # Build text for MDL threshold results under CV and over CV branches
-    n_under_CV_over_MDL = df['n_under_CV_over_MDL'].iloc[0]
-    str_under_CV_over_MDL = f'$\\geq$ MDL (N = {n_under_CV_over_MDL:,})'
-    n_under_CV_under_MDL = df['n_under_CV_under_MDL'].iloc[0]
-    str_under_CV_under_MDL = f'$<$ MDL (N = {n_under_CV_under_MDL:,})'
-    n_over_CV_over_MDL = df['n_over_CV_over_MDL'].iloc[0]
-    str_over_CV_over_MDL = f'$\\geq$ MDL (N = {n_over_CV_over_MDL:,})'
-    n_over_CV_under_MDL = df['n_over_CV_under_MDL'].iloc[0]
-    str_over_CV_under_MDL = f'$<$ MDL (N = {n_over_CV_under_MDL:,})'
+    n_under_CV_over_MDL = df["n_under_CV_over_MDL"].iloc[0]
+    str_under_CV_over_MDL = f"$\\geq$ MDL (N = {n_under_CV_over_MDL:,})"
+    n_under_CV_under_MDL = df["n_under_CV_under_MDL"].iloc[0]
+    str_under_CV_under_MDL = f"$<$ MDL (N = {n_under_CV_under_MDL:,})"
+    n_over_CV_over_MDL = df["n_over_CV_over_MDL"].iloc[0]
+    str_over_CV_over_MDL = f"$\\geq$ MDL (N = {n_over_CV_over_MDL:,})"
+    n_over_CV_under_MDL = df["n_over_CV_under_MDL"].iloc[0]
+    str_over_CV_under_MDL = f"$<$ MDL (N = {n_over_CV_under_MDL:,})"
 
     # Threshold values for annotations
-    replicate_threshold = df['replicate_threshold'].iloc[0]
-    replicate_threshold_str = f'\\textbf{{Replicate Threshold = {replicate_threshold}}}'
-    CV_threshold = df['CV_threshold'].iloc[0]
-    CV_threshold_str = f'\\textbf{{CV Threshold = {CV_threshold}}}'
-    MDL = r'$\bigsymbol{\mu}_{\text{MB}} \text{ + } \bigsymbol{3\sigma}_{\text{MB}}$'
-    MDL_str = f'\\textbf{{MDL = {MDL}}}'
+    replicate_threshold = df["replicate_threshold"].iloc[0]
+    replicate_threshold_str = f"\\textbf{{Replicate Threshold = {replicate_threshold}}}"
+    CV_threshold = df["CV_threshold"].iloc[0]
+    CV_threshold_str = f"\\textbf{{CV Threshold = {CV_threshold}}}"
+    MDL = r"$\bigsymbol{\mu}_{\text{MB}} \text{ + } \bigsymbol{3\sigma}_{\text{MB}}$"
+    MDL_str = f"\\textbf{{MDL = {MDL}}}"
 
     # Box y-positions and arrow width
     y_row1, y_row2, y_row3, y_row4 = 110, 60, 10, -30
@@ -84,53 +88,304 @@ def make_tree():
     # Axis limits
     xlims = (-50, 135)
     ylims = (-50, 135)
-    logic_tree = LogicTree(xlims=xlims, ylims=ylims, title='Logic Tree - Sample Occurence')
+    logic_tree = LogicTree(
+        xlims=xlims, ylims=ylims, title="Logic Tree - Sample Occurence"
+    )
 
     # Add first row boxes
-    logic_tree.add_box(xpos=75, ypos=y_row1, text=str_total_sample_occurence, box_name="Total Sample Occurence", bbox_fc='black', bbox_ec='white')
-    logic_tree.add_box(xpos=99, ypos=y_row1, text=str_missing_occurence, ha='left', box_name="Missing", bbox_fc='dimgrey', bbox_ec='xkcd:light blue grey')
+    logic_tree.add_box(
+        xpos=75,
+        ypos=y_row1,
+        text=str_total_sample_occurence,
+        box_name="Total Sample Occurence",
+        bbox_fc="black",
+        bbox_ec="white",
+    )
+    logic_tree.add_box(
+        xpos=99,
+        ypos=y_row1,
+        text=str_missing_occurence,
+        ha="left",
+        box_name="Missing",
+        bbox_fc="dimgrey",
+        bbox_ec="xkcd:light blue grey",
+    )
 
     # Add second row boxes
-    logic_tree.add_box(xpos=55, ypos=y_row2, text=str_over_replicate, ha='right', box_name="Over Replicate", bbox_fc='black', bbox_ec='xkcd:bright sky blue')
-    logic_tree.add_box(xpos=65, ypos=y_row2, text=str_under_replicate, ha='left', box_name="Under Replicate", bbox_fc='dimgrey', bbox_ec='xkcd:light blue grey')
+    logic_tree.add_box(
+        xpos=55,
+        ypos=y_row2,
+        text=str_over_replicate,
+        ha="right",
+        box_name="Over Replicate",
+        bbox_fc="black",
+        bbox_ec="xkcd:bright sky blue",
+    )
+    logic_tree.add_box(
+        xpos=65,
+        ypos=y_row2,
+        text=str_under_replicate,
+        ha="left",
+        box_name="Under Replicate",
+        bbox_fc="dimgrey",
+        bbox_ec="xkcd:light blue grey",
+    )
 
     # Add third row boxes
-    logic_tree.add_box(xpos=20, ypos=y_row3, text=str_under_CV, ha='right', box_name="Under CV", bbox_fc='black', bbox_ec='xkcd:water blue')
-    logic_tree.add_box(xpos=71, ypos=y_row3, text=str_over_CV, ha='left', box_name="Over CV", bbox_fc='xkcd:cherry', bbox_ec='xkcd:rosa')
+    logic_tree.add_box(
+        xpos=20,
+        ypos=y_row3,
+        text=str_under_CV,
+        ha="right",
+        box_name="Under CV",
+        bbox_fc="black",
+        bbox_ec="xkcd:water blue",
+    )
+    logic_tree.add_box(
+        xpos=71,
+        ypos=y_row3,
+        text=str_over_CV,
+        ha="left",
+        box_name="Over CV",
+        bbox_fc="xkcd:cherry",
+        bbox_ec="xkcd:rosa",
+    )
 
     # Add fourth row boxes
-    logic_tree.add_box(xpos=-15, ypos=y_row4, text=str_under_CV_over_MDL, ha='right', box_name="Under CV, Over MDL", bbox_fc='black', bbox_ec='xkcd:ocean')
-    logic_tree.add_box(xpos=-6, ypos=y_row4, text=str_under_CV_under_MDL, ha='left', box_name="Under CV, Under MDL", bbox_fc='dimgrey', bbox_ec='xkcd:light blue grey')
-    logic_tree.add_box(xpos=96, ypos=y_row4, text=str_over_CV_over_MDL, ha='right', box_name="Over CV, Over MDL", bbox_fc='xkcd:rust orange', bbox_ec='xkcd:light salmon')
-    logic_tree.add_box(xpos=105, ypos=y_row4, text=str_over_CV_under_MDL, ha='left', box_name="Over CV, Under MDL", bbox_fc='dimgrey', bbox_ec='xkcd:light blue grey')
+    logic_tree.add_box(
+        xpos=-15,
+        ypos=y_row4,
+        text=str_under_CV_over_MDL,
+        ha="right",
+        box_name="Under CV, Over MDL",
+        bbox_fc="black",
+        bbox_ec="xkcd:ocean",
+    )
+    logic_tree.add_box(
+        xpos=-6,
+        ypos=y_row4,
+        text=str_under_CV_under_MDL,
+        ha="left",
+        box_name="Under CV, Under MDL",
+        bbox_fc="dimgrey",
+        bbox_ec="xkcd:light blue grey",
+    )
+    logic_tree.add_box(
+        xpos=96,
+        ypos=y_row4,
+        text=str_over_CV_over_MDL,
+        ha="right",
+        box_name="Over CV, Over MDL",
+        bbox_fc="xkcd:rust orange",
+        bbox_ec="xkcd:light salmon",
+    )
+    logic_tree.add_box(
+        xpos=105,
+        ypos=y_row4,
+        text=str_over_CV_under_MDL,
+        ha="left",
+        box_name="Over CV, Under MDL",
+        bbox_fc="dimgrey",
+        bbox_ec="xkcd:light blue grey",
+    )
 
     # Add arrows and bifurcations connecting boxes
-    logic_tree.add_connection(logic_tree.boxes['Total Sample Occurence'], logic_tree.boxes['Missing'], arrow_head=True, arrow_width=arr_width, fill_connection=True, tip_offset=0.8, lw=1.2)
-    logic_tree.add_connection_biSplit(logic_tree.boxes['Total Sample Occurence'], logic_tree.boxes['Over Replicate'], logic_tree.boxes['Under Replicate'], arrow_head=True, arrow_width=arr_width, fill_connection=True, fc_A='ec', ec_B='xkcd:off white', fc_B='ec', lw=1.3, tip_offset=tip_offset)
-    logic_tree.add_connection_biSplit(logic_tree.boxes['Over Replicate'], logic_tree.boxes['Under CV'], logic_tree.boxes['Over CV'], arrow_head=True, arrow_width=arr_width, fill_connection=True, fc_A='ec', ec_B='xkcd:off white', fc_B='ec', lw=1.3, tip_offset=tip_offset)
-    logic_tree.add_connection_biSplit(logic_tree.boxes['Under CV'], logic_tree.boxes['Under CV, Over MDL'], logic_tree.boxes['Under CV, Under MDL'], arrow_head=True, arrow_width=arr_width, fill_connection=True, fc_A='ec', ec_B='xkcd:off white', fc_B='ec', lw=1.3, tip_offset=tip_offset)
-    logic_tree.add_connection_biSplit(logic_tree.boxes['Over CV'], logic_tree.boxes['Over CV, Over MDL'], logic_tree.boxes['Over CV, Under MDL'], arrow_head=True, arrow_width=arr_width, fill_connection=True, lw=1.3, tip_offset=tip_offset)
+    logic_tree.add_connection(
+        logic_tree.boxes["Total Sample Occurence"],
+        logic_tree.boxes["Missing"],
+        arrow_head=True,
+        arrow_width=arr_width,
+        fill_connection=True,
+        tip_offset=0.8,
+        lw=1.2,
+    )
+    logic_tree.add_connection_biSplit(
+        logic_tree.boxes["Total Sample Occurence"],
+        logic_tree.boxes["Over Replicate"],
+        logic_tree.boxes["Under Replicate"],
+        arrow_head=True,
+        arrow_width=arr_width,
+        fill_connection=True,
+        fc_A="ec",
+        ec_B="xkcd:off white",
+        fc_B="ec",
+        lw=1.3,
+        tip_offset=tip_offset,
+    )
+    logic_tree.add_connection_biSplit(
+        logic_tree.boxes["Over Replicate"],
+        logic_tree.boxes["Under CV"],
+        logic_tree.boxes["Over CV"],
+        arrow_head=True,
+        arrow_width=arr_width,
+        fill_connection=True,
+        fc_A="ec",
+        ec_B="xkcd:off white",
+        fc_B="ec",
+        lw=1.3,
+        tip_offset=tip_offset,
+    )
+    logic_tree.add_connection_biSplit(
+        logic_tree.boxes["Under CV"],
+        logic_tree.boxes["Under CV, Over MDL"],
+        logic_tree.boxes["Under CV, Under MDL"],
+        arrow_head=True,
+        arrow_width=arr_width,
+        fill_connection=True,
+        fc_A="ec",
+        ec_B="xkcd:off white",
+        fc_B="ec",
+        lw=1.3,
+        tip_offset=tip_offset,
+    )
+    logic_tree.add_connection_biSplit(
+        logic_tree.boxes["Over CV"],
+        logic_tree.boxes["Over CV, Over MDL"],
+        logic_tree.boxes["Over CV, Under MDL"],
+        arrow_head=True,
+        arrow_width=arr_width,
+        fill_connection=True,
+        lw=1.3,
+        tip_offset=tip_offset,
+    )
 
     # Add annotation boxes for thresholds
-    annotation_font = {'fontsize': 16, 'color': 'white'} # you could adjust 'fontname' here too!
+    annotation_font = {
+        "fontsize": 16,
+        "color": "white",
+    }  # you could adjust 'fontname' here too!
     y_row1_5 = (y_row1 + y_row2) / 2
     y_row2_5 = (y_row2 + y_row3) / 2
     y_row3_5 = (y_row3 + y_row4) / 2
 
-    logic_tree.add_box(xpos=-4, ypos=y_row1_5, text=replicate_threshold_str, box_name="Replicate Threshold", bbox_fc=(1,1,1,0), bbox_ec=(1,1,1,0), ha='right', va='center', bbox_style=BoxStyle('Square', pad=0.3), font_dict=annotation_font, lw=1, use_tex_rendering=True, ul=True)
-    logic_tree.add_box(xpos=-32, ypos=y_row2_5, text=CV_threshold_str, box_name="CV Threshold", bbox_fc=(1,1,1,0), bbox_ec=(1,1,1,0), ha='right', va='center', bbox_style=BoxStyle('Square', pad=0.3), font_dict=annotation_font, lw=1, use_tex_rendering=True, ul=True)
-    logic_tree.add_box(xpos=-44, ypos=y_row3_5, text=MDL_str, box_name="MDL", bbox_fc=(1,1,1,0), bbox_ec=(1,1,1,0), ha='right', va='center', bbox_style=BoxStyle('Square', pad=0.3), font_dict=annotation_font, lw=1, use_tex_rendering=True, ul=True, ul_depth_width=('8pt', '1pt'), angle=20)
+    logic_tree.add_box(
+        xpos=-4,
+        ypos=y_row1_5,
+        text=replicate_threshold_str,
+        box_name="Replicate Threshold",
+        bbox_fc=(1, 1, 1, 0),
+        bbox_ec=(1, 1, 1, 0),
+        ha="right",
+        va="center",
+        bbox_style=BoxStyle("Square", pad=0.3),
+        font_dict=annotation_font,
+        lw=1,
+        use_tex_rendering=True,
+        ul=True,
+    )
+    logic_tree.add_box(
+        xpos=-32,
+        ypos=y_row2_5,
+        text=CV_threshold_str,
+        box_name="CV Threshold",
+        bbox_fc=(1, 1, 1, 0),
+        bbox_ec=(1, 1, 1, 0),
+        ha="right",
+        va="center",
+        bbox_style=BoxStyle("Square", pad=0.3),
+        font_dict=annotation_font,
+        lw=1,
+        use_tex_rendering=True,
+        ul=True,
+    )
+    logic_tree.add_box(
+        xpos=-44,
+        ypos=y_row3_5,
+        text=MDL_str,
+        box_name="MDL",
+        bbox_fc=(1, 1, 1, 0),
+        bbox_ec=(1, 1, 1, 0),
+        ha="right",
+        va="center",
+        bbox_style=BoxStyle("Square", pad=0.3),
+        font_dict=annotation_font,
+        lw=1,
+        use_tex_rendering=True,
+        ul=True,
+        ul_depth_width=("8pt", "1pt"),
+        angle=20,
+    )
 
     # Add kept/removed/flag text annotations
-    logic_tree.add_box(xpos=27, ypos=y_row1_5+arr_width*0.85, text=r'\textit{\textbf{Kept}}', box_name="Kept", bbox_fc=(1,1,1,0), bbox_ec=(1,1,1,0), ha='right', va='bottom', bbox_style=BoxStyle('Square', pad=0.1), font_dict=annotation_font, use_tex_rendering=True, fs=12)
-    logic_tree.add_box(xpos=65, ypos=y_row1_5+arr_width*0.85, text=r'\textit{\textbf{Removed}}', box_name="Removed", bbox_fc=(1,1,1,0), bbox_ec=(1,1,1,0), ha='center', va='bottom', bbox_style=BoxStyle('Square', pad=0.1), font_dict=annotation_font, use_tex_rendering=True, fs=12)
-    logic_tree.add_box(xpos=56, ypos=y_row2_5+arr_width*0.85, text=r'\textit{\textbf{CV Flag}}', box_name="CV Flag", bbox_fc=(1,1,1,0), bbox_ec=(1,1,1,0), ha='center', va='bottom', bbox_style=BoxStyle('Square', pad=0.1), font_dict=annotation_font, use_tex_rendering=True, fs=12)
-    logic_tree.add_box(xpos=-9, ypos=y_row3_5+arr_width*0.85, text=r'\textit{\textbf{MDL Flag}}', box_name="MDL Flag Left", bbox_fc=(1,1,1,0), bbox_ec=(1,1,1,0), ha='left', va='bottom', bbox_style=BoxStyle('Square', pad=0.1), font_dict=annotation_font, use_tex_rendering=True, fs=12)
-    logic_tree.add_box(xpos=105, ypos=y_row3_5+arr_width*0.85, text=r'\textit{\textbf{MDL Flag}}', box_name="MDL Flag Right", bbox_fc=(1,1,1,0), bbox_ec=(1,1,1,0), ha='left', va='bottom', bbox_style=BoxStyle('Square', pad=0.1), font_dict=annotation_font, use_tex_rendering=True, fs=12)
+    logic_tree.add_box(
+        xpos=27,
+        ypos=y_row1_5 + arr_width * 0.85,
+        text=r"\textit{\textbf{Kept}}",
+        box_name="Kept",
+        bbox_fc=(1, 1, 1, 0),
+        bbox_ec=(1, 1, 1, 0),
+        ha="right",
+        va="bottom",
+        bbox_style=BoxStyle("Square", pad=0.1),
+        font_dict=annotation_font,
+        use_tex_rendering=True,
+        fs=12,
+    )
+    logic_tree.add_box(
+        xpos=65,
+        ypos=y_row1_5 + arr_width * 0.85,
+        text=r"\textit{\textbf{Removed}}",
+        box_name="Removed",
+        bbox_fc=(1, 1, 1, 0),
+        bbox_ec=(1, 1, 1, 0),
+        ha="center",
+        va="bottom",
+        bbox_style=BoxStyle("Square", pad=0.1),
+        font_dict=annotation_font,
+        use_tex_rendering=True,
+        fs=12,
+    )
+    logic_tree.add_box(
+        xpos=56,
+        ypos=y_row2_5 + arr_width * 0.85,
+        text=r"\textit{\textbf{CV Flag}}",
+        box_name="CV Flag",
+        bbox_fc=(1, 1, 1, 0),
+        bbox_ec=(1, 1, 1, 0),
+        ha="center",
+        va="bottom",
+        bbox_style=BoxStyle("Square", pad=0.1),
+        font_dict=annotation_font,
+        use_tex_rendering=True,
+        fs=12,
+    )
+    logic_tree.add_box(
+        xpos=-9,
+        ypos=y_row3_5 + arr_width * 0.85,
+        text=r"\textit{\textbf{MDL Flag}}",
+        box_name="MDL Flag Left",
+        bbox_fc=(1, 1, 1, 0),
+        bbox_ec=(1, 1, 1, 0),
+        ha="left",
+        va="bottom",
+        bbox_style=BoxStyle("Square", pad=0.1),
+        font_dict=annotation_font,
+        use_tex_rendering=True,
+        fs=12,
+    )
+    logic_tree.add_box(
+        xpos=105,
+        ypos=y_row3_5 + arr_width * 0.85,
+        text=r"\textit{\textbf{MDL Flag}}",
+        box_name="MDL Flag Right",
+        bbox_fc=(1, 1, 1, 0),
+        bbox_ec=(1, 1, 1, 0),
+        ha="left",
+        va="bottom",
+        bbox_style=BoxStyle("Square", pad=0.1),
+        font_dict=annotation_font,
+        use_tex_rendering=True,
+        fs=12,
+    )
 
     # Add title and save
-    logic_tree.make_title(pos='left')
-    logic_tree.save_as_png(file_name=Path(__file__).resolve().parent / "DecisionTree_NTA-Example.png", dpi=900, content_padding=0.25)
+    logic_tree.make_title(pos="left")
+    logic_tree.save_as_png(
+        file_name=Path(__file__).resolve().parent / "DecisionTree_NTA-Example.png",
+        dpi=900,
+        content_padding=0.25,
+    )
+
 
-if __name__ == '__main__':
+if __name__ == "__main__":
     make_tree()
diff --git a/logictree/ArrowETC.py b/logictree/ArrowETC.py
deleted file mode 100644
index d7f2a46..0000000
--- a/logictree/ArrowETC.py
+++ /dev/null
@@ -1,428 +0,0 @@
-"""
-ArrowETC module for creating multi-segmented arrows and path-based shapes with explicit vertex control.
-
-This module defines the ArrowETC class, which allows building complex polygonal
-shapes by connecting multiple line segments in sequence. While it can produce
-classic arrows with optional arrowheads, it can also create segmented rectangles
-and arbitrary paths useful for connectors, pipes, or other linear features
-in logic tree diagrams, flowcharts, or technical illustrations.
-
-ArrowETC stores extensive metadata for each arrow, including segment lengths,
-angles, and a complete set of polygon vertices outlining the arrow body. These
-attributes remain accessible after construction, enabling downstream tasks such as
-collision detection, dynamic alignment, or generating custom labels tied to
-specific arrow joints.
-
-**WARNING**: ArrowETC assumes the arrows or segmented shapes will be plotted
-in an environment with an **equal aspect ratio**. The saved or displayed
-arrow polygon does not automatically account for distorted aspect ratiosâ€”if you
-use an unequal aspect ratio (e.g., `ax.set_aspect('auto')`), your shapes may appear
-skewed or "out of whack." It is the user's responsibility to either:
-1) ensure plots using ArrowETC have an equal aspect ratio, or
-2) manually transform the arrow vertices to compensate for an intended uneven aspect ratio.
-
-Features
----------
-- Explicit calculation of each vertex, including miter joints at corners.
-- Supports straight and multi-bend paths with arbitrary angles.
-- Optional flared arrowhead at the final path point.
-- Suitable for creating segmented rectangles (shaft-only shapes) by disabling the arrowhead.
-- Stores metadata such as:
-  - `self.vertices`: polygon vertex coordinates,
-  - `self.segment_lengths`: lengths of all segments,
-  - `self.path_angles`: angles each segment makes with the x-axis.
-
-Examples
----------
-Basic arrow with head:
-
->>> from logictree.ArrowETC import ArrowETC
->>> arrow = ArrowETC(path=[(0, 0), (0, 5)], arrow_width=1.5, arrow_head=True)
->>> arrow.save_arrow(name='example_arrow.png')
-
-Segmented rectangular path without arrowhead:
-
->>> rect_arrow = ArrowETC(path=[(0, 0), (5, 0), (5, -3)], arrow_width=1.0, arrow_head=False)
->>> rect_arrow.save_arrow(name='segmented_rect.png')
-
-Plotting in a custom figure:
-
->>> import matplotlib.pyplot as plt
->>> fig, ax = plt.subplots()
->>> ax.set_aspect('equal')
->>> ax.fill(rect_arrow.x_vertices, rect_arrow.y_vertices, color='lightblue')
->>> ax.plot(rect_arrow.x_vertices, rect_arrow.y_vertices, color='black')
->>> plt.show()
-
-Typical use cases
-------------------
-- Drawing arrows or right-angle connectors in logic diagrams.
-- Building segmented pipes, buses, or flow lines with multiple corners.
-- Aligning shapes precisely in custom diagrams using stored vertex metadata.
-
-Dependencies
--------------
-- Python packages: numpy, matplotlib.
-"""
-from typing import List, Optional, Tuple 
-
-import matplotlib.pyplot as plt
-import numpy as np
-
-class ArrowETC:
-    """
-    An arrow object with detailed vertex control for multi-segmented arrows.
-
-    ArrowETC provides arrows constructed from a series of connected line segments,
-    storing coordinates of every vertex to make it easy to generate complex arrows
-    with multiple joints. Unlike matplotlib's FancyArrow, it gives explicit access
-    to arrow geometry for alignment and advanced layout tasks.
-
-    Parameters
-    ----------
-    path : list of tuple of float or int
-        List of points defining the path of the arrow. Each tuple is the
-        center of an endpoint of a line segment. The first point is the
-        "butt" (tail), and the last point is the arrow "head".
-    arrow_width : float or int
-        The width of the arrow shaft in data coordinates.
-    arrow_head : bool, optional
-        If True, an arrowhead will be added at the end of the arrow path,
-        using the last point in `path` as the tip. If False, the arrow ends
-        with a flat edge.
-
-    Attributes
-    ----------
-    path : list of tuple
-        Input path defining the arrow's geometry.
-    x_path : list of float
-        List of x-coordinates along the arrow path.
-    y_path : list of float
-        List of y-coordinates along the arrow path.
-    n_path : int
-        Number of points in the path.
-    n_segments : int
-        Number of line segments (n_path - 1).
-    segment_lengths : list of float
-        Lengths of each line segment.
-    path_angles : list of float
-        Angles (radians) each segment makes with the positive x-axis.
-    vertices : ndarray of shape (N, 2)
-        Array of vertices defining the arrow polygon.
-    x_vertices : ndarray of float
-        X-coordinates of the arrow polygon vertices.
-    y_vertices : ndarray of float
-        Y-coordinates of the arrow polygon vertices.
-    """
-    def __init__(
-        self, 
-        path: List[Tuple[float, float]], 
-        arrow_width: float, 
-        arrow_head: bool = False
-    ) -> None:
-        self.path = path
-        self.x_path = [coord[0] for coord in path]
-        self.y_path = [coord[1] for coord in path]
-        self.n_path = len(path)
-        self.n_segments = self.n_path - 1 # actual number of line segments
-        self.n_segment_vertices = 2*(1 + self.n_segments) # vertex count w/o arrow head
-        self.segment_lengths = self._get_segment_length()
-        if arrow_head == True:
-            self.n_vertices = self.n_segment_vertices + 3 # vertex count w/ arrow head
-        else:
-            self.n_vertices = self.n_segment_vertices
-        # find the angles each segment makes with the (+) horizontal (CCW)
-        self.path_angles = self._get_angles(path=path)
-        # getting angles in reverse is essential for the way vertices are calculated
-        self.reverse_path_angles = self._get_angles(path=path[::-1])
-        self.arrow_width = arrow_width
-        self.arrow_head = arrow_head
-        # verts need to wrap back around to first vertex for plotting
-        verts = self._get_vertices()
-        self.vertices = np.vstack((verts, verts[0]))
-        self.x_vertices = self.vertices[:, 0]
-        self.y_vertices = self.vertices[:, 1]
-    
-    def _get_vertices(self) -> np.ndarray:
-        """
-        Compute the vertices outlining the multi-segment arrow polygon.
-
-        Vertices are calculated by traversing the arrow path twice:
-        once in forward order to generate one side of the arrow shaft,
-        and once in reverse order to generate the other side, optionally
-        inserting an arrowhead at the tip.
-
-        Returns
-        -------
-        ndarray of shape (N, 2)
-            Array of vertices as (x, y) coordinates in data space,
-            ordered clockwise around the arrow polygon.
-        """
-        path = self.path
-        vertices = []
-        # iterate through the path normally first, get first half of vertices
-        for i in range(self.n_path-1):
-            # get the next two neighboring points starting at 'butt'
-            A, B = path[i], path[i+1]
-            Ax, Ay = A[0], A[1]
-            Bx, By = B[0], B[1]
-            theta_1 = self.path_angles[i] # angle of this line segment
-            # at the end of this half of vertices, there wont be an angle for next segment
-            theta_2 = self.path_angles[i+1] if i + 1 < self.n_segments else None
-            
-            # first vertex is special and needs to be calculated separately
-            if i == 0:
-                vert = self._get_first_vertex(Ax, Ay, theta_1)
-                vertices.append(vert)
-            
-            # Get the vertex
-            vert = self._vertex_from_angle(Bx, By, theta_1, theta_2)
-            vertices.append(vert)
-        
-        # generate an arrow head if desired
-        if self.arrow_head:
-            B = vertices[-1]
-            Bx, By = B[0], B[1]
-            verts = self._get_arrow_head_vertices(path[-1][0], path[-1][1], theta_1)
-            # replace last vertex with new one to make room for arrow head
-            vertices[-1] = verts[0]
-            # fill in the 3 vertices of arrow head
-            vertices.extend(verts[1:])
-            
-        # now iterate through path backwards to get the last half of vertices
-        path = path[::-1]
-        for i in range(self.n_path-1):
-            # get the next two neighboring points starting at 'butt'
-            A, B = path[i], path[i+1]
-            Ax, Ay = A[0], A[1]
-            Bx, By = B[0], B[1]
-            theta_1 = self.reverse_path_angles[i] # angle of this line segment
-            # at the end of this half of vertices, there wont be an angle for next segment
-            theta_2 = self.reverse_path_angles[i+1] if i + 1 < self.n_segments else None
-                
-            # first vertex is special and needs to be calculated separately, If we have no arrow head
-            if i == 0 and not self.arrow_head:
-                vert = self._get_first_vertex(Ax, Ay, theta_1)
-                vertices.append(vert)
-            # Get the vertex
-            vert = self._vertex_from_angle(Bx, By, theta_1, theta_2)
-            vertices.append(vert)
-
-        return np.array(vertices, dtype=float)
-
-    def _get_arrow_head_vertices(
-        self,
-        tipx: float,
-        tipy: float,
-        theta_1: float
-    ) -> List[np.ndarray]:
-        """
-        Calculate five points forming the arrowhead with shaft sides extending
-        straight to the arrowhead base line without kinks.
-        Returns [A, left_base, tip, right_base, E].
-        """
-        shaft_width = self.arrow_width
-        head_width = shaft_width * 2.0
-        head_length = shaft_width * 1.5
-
-        # Unit vectors
-        dir_x, dir_y = np.cos(theta_1), np.sin(theta_1)
-        perp_x, perp_y = -dir_y, dir_x
-
-        # Tip point
-        tip = np.array([tipx, tipy], dtype=float)
-
-        # Base center: base of the arrowhead along shaft
-        base_cx = tipx - head_length * dir_x
-        base_cy = tipy - head_length * dir_y
-
-        # Left and right points on the arrowhead base line
-        left_base = np.array([
-            base_cx + (head_width / 2) * perp_x,
-            base_cy + (head_width / 2) * perp_y
-        ])
-        right_base = np.array([
-            base_cx - (head_width / 2) * perp_x,
-            base_cy - (head_width / 2) * perp_y
-        ])
-
-        # Shaft left line: parallel to shaft, offset by +shaft_width/2
-        shaft_dx, shaft_dy = dir_x, dir_y
-        shaft_left_point = np.array([
-            base_cx + (shaft_width/2) * perp_x,
-            base_cy + (shaft_width/2) * perp_y
-        ])
-
-        # Shaft right line: parallel to shaft, offset by -shaft_width/2
-        shaft_right_point = np.array([
-            base_cx - (shaft_width/2) * perp_x,
-            base_cy - (shaft_width/2) * perp_y
-        ])
-
-        def line_intersection(p1, d1, p2, d2):
-            """
-            Computes intersection of lines p1 + t*d1 and p2 + s*d2.
-            """
-            A = np.array([d1, -d2]).T
-            if np.linalg.matrix_rank(A) < 2:
-                # Parallel lines: return base point directly to avoid NaN
-                return p2
-            t_s = np.linalg.solve(A, p2 - p1)
-            return p1 + t_s[0]*d1
-
-        # Compute A: where shaft left edge intersects base line
-        A = line_intersection(
-            shaft_left_point, np.array([shaft_dx, shaft_dy]),
-            left_base, right_base - left_base
-        )
-
-        # Compute E: where shaft right edge intersects base line
-        E = line_intersection(
-            shaft_right_point, np.array([shaft_dx, shaft_dy]),
-            left_base, right_base - left_base
-        )
-
-        return [A, left_base, tip, right_base, E]
-
-    
-    def _get_first_vertex(self, Ax: float, Ay: float, theta_1: float) -> np.ndarray:
-        """
-        Calculate the first side vertex at the butt of the arrow,
-        offset perpendicular to the first segment angle.
-        """
-        w2 = self.arrow_width / 2
-        offset_angle = theta_1 + np.pi/2  # left side offset
-        dx = w2 * np.cos(offset_angle)
-        dy = w2 * np.sin(offset_angle)
-
-        return np.array([Ax + dx, Ay + dy])
-            
-    def _vertex_from_angle(self, Bx: float, By: float, theta_1: float, theta_2: Optional[float]) -> np.ndarray:
-        """
-        Calculate a polygon vertex at a joint between two arbitrary segments,
-        using miter-join logic to produce sharp corners without kinks.
-
-        Parameters
-        ----------
-        Bx, By : float
-            Coordinates of the joint between segments.
-        theta_1 : float
-            Angle of incoming segment.
-        theta_2 : float or None
-            Angle of outgoing segment. None if it's the last segment.
-
-        Returns
-        -------
-        ndarray of float
-            Coordinates of the calculated vertex as [x, y].
-        """
-        w2 = self.arrow_width / 2
-        point = np.array([Bx, By], dtype=float)
-
-        dir1 = np.array([np.cos(theta_1), np.sin(theta_1)])
-        perp1 = np.array([-dir1[1], dir1[0]])
-        A = point + w2 * perp1
-        dA = dir1
-
-        if theta_2 is None:
-            return A
-
-        dir2 = np.array([np.cos(theta_2), np.sin(theta_2)])
-        perp2 = np.array([-dir2[1], dir2[0]])
-        B = point + w2 * perp2
-        dB = dir2
-
-        mat = np.column_stack((dA, -dB))
-        if np.linalg.matrix_rank(mat) < 2:
-            avg_normal = (perp1 + perp2) / 2
-            avg_normal /= np.linalg.norm(avg_normal)
-            return point + w2 * avg_normal
-
-        t = np.linalg.solve(mat, B - A)[0]
-        return A + t * dA
-    
-    def _get_angles(self, path: List[Tuple[float, float]]) -> List[float]:
-        """
-        Calculate angles each segment makes with the positive x-axis,
-        allowing arbitrary directions.
-
-        Parameters
-        ----------
-        path : list of (x, y)
-            Arrow path points.
-
-        Returns
-        -------
-        list of float
-            Angles (radians) of each segment relative to +x axis.
-        """
-        angles = []
-        for i in range(self.n_segments):
-            p1, p2 = path[i], path[i + 1]
-            dx = p2[0] - p1[0]
-            dy = p2[1] - p1[1]
-            theta = np.arctan2(dy, dx) % (2 * np.pi)
-            angles.append(theta)
-
-        return angles
-    
-    def _get_segment_length(self) -> List[float]:
-        """
-        Compute the Euclidean length of each arrow segment.
-
-        Returns
-        -------
-        list of float
-            Distances between consecutive path points defining each segment.
-        """
-        distances = []
-        for i in range(self.n_segments):
-            p1, p2 = self.path[i], self.path[i+1]
-            x1, y1 = p1[0], p1[1]
-            x2, y2 = p2[0], p2[1]
-            d = np.sqrt((x2-x1)**2 + (y2-y1)**2)
-            distances.append(d)
-
-        return distances
-    
-    def save_arrow(self, name: str = './arrow.png', ec: str = 'white', fc: str = 'cyan', lw: float = 0.6) -> None:
-        """
-        Display the arrow using matplotlib.
-
-        Generates a plot of the arrow polygon with specified line and
-        fill colors.
-
-        Parameters
-        ----------
-        name : str, optional
-            Name / path of the resulting png. Default is './arrow.png'.
-        ec : str, optional
-            Edge color of the arrow outline. Default is 'white'.
-        fc : str, optional
-            Fill color of the arrow body. Default is 'cyan'.
-        lw : float, optional
-            Line width of the arrow outline. Default is 0.6.
-        """
-        x = self.x_vertices
-        y = self.y_vertices
-        # generate figure and axis to put boxes in
-        _, ax = plt.subplots(figsize=(8, 8), frameon=True, facecolor='black')
-        ax.axis('off')
-        ax.set_aspect('equal')
-        # set axis bounds
-        xdiff = (max(x) - min(x)) * 0.2
-        ydiff = (max(y) - min(y)) * 0.2
-        xmin = min(x) - xdiff
-        xmax = max(x) + xdiff
-        ymin = min(y) - ydiff
-        ymax = max(y) + ydiff
-        ax.set_xlim(xmin, xmax)
-        ax.set_ylim(ymin, ymax)
-        # plot lines and vertices
-        ax.plot(x, y, color=ec, lw=lw, zorder=100)
-        ax.fill(x, y, color=fc)
-        ax.set_aspect('equal')
-        
-        plt.savefig(name)
-                    
-__all__ = ["ArrowETC"]
diff --git a/logictree/LogicBoxETC.py b/logictree/LogicBoxETC.py
index 7843f09..f1486a2 100644
--- a/logictree/LogicBoxETC.py
+++ b/logictree/LogicBoxETC.py
@@ -2,10 +2,12 @@
 in logic tree diagrams. Each LogicBox supports custom text, styling, and
 positioning options using matplotlib's BoxStyle.
 """
+
 from typing import Any, Dict, Literal, Optional
 
 from matplotlib.patches import BoxStyle
 
+
 class LogicBox:
     """
     A box object for use in logic tree diagrams, containing text and visual styling.
@@ -75,23 +77,24 @@ class LogicBox:
         Coordinates of the box edges, set during layout.
     width, height : float or None
         Dimensions of the box, set during layout.
-    x_center, y_center : float or None
+    xCenter, yCenter : float or None
         Coordinates of the box center, set during layout.
     """
+
     def __init__(
-        self, 
-        xpos: float, 
-        ypos: float, 
-        text: str, 
-        box_name: str, 
-        bbox_fc: str, 
-        bbox_ec: str, 
-        font_dict: Dict[str, Any], 
-        bbox_style: Optional[BoxStyle] = BoxStyle('Square', pad=0.5), 
-        lw: float = 1.6, 
-        va: Literal['top', 'center', 'bottom'] = 'center', 
-        ha: Literal['left', 'center', 'right'] = 'left',
-        angle: float = 0.0
+        self,
+        xpos: float,
+        ypos: float,
+        text: str,
+        box_name: str,
+        bbox_fc: str,
+        bbox_ec: str,
+        font_dict: Dict[str, Any],
+        bbox_style: BoxStyle = BoxStyle("Square", pad=0.5),
+        lw: float = 1.6,
+        va: Literal["top", "center", "bottom"] = "center",
+        ha: Literal["left", "center", "right"] = "left",
+        angle: float = 0.0,
     ) -> None:
         # data validation for literals (va and ha parameters)
         if va not in ("top", "center", "bottom"):
@@ -103,7 +106,7 @@ class LogicBox:
         my_style = self._my_bbox_style(
             facecolor=bbox_fc, edgecolor=bbox_ec, linewidth=lw, boxstyle=bbox_style
         )
-        
+
         self.x = xpos
         self.y = ypos
         self.text = text
@@ -116,21 +119,17 @@ class LogicBox:
         self.ha = ha
         self.lw = lw
         self.angle = angle
-        self.xLeft = None
-        self.xRight = None
-        self.yBottom = None
-        self.yTop = None
-        self.width = None
-        self.height = None
-        self.x_center = None
-        self.y_center = None
-        
+        self.xLeft: Optional[float] = None
+        self.xRight: Optional[float] = None
+        self.yBottom: Optional[float] = None
+        self.yTop: Optional[float] = None
+        self.width: Optional[float] = None
+        self.height: Optional[float] = None
+        self.xCenter: Optional[float] = None
+        self.yCenter: Optional[float] = None
+
     def _my_bbox_style(
-        self,
-        facecolor: str,
-        edgecolor: str,
-        linewidth: float,
-        boxstyle: BoxStyle
+        self, facecolor: str, edgecolor: str, linewidth: float, boxstyle: BoxStyle
     ) -> Dict[str, Any]:
         """
         Create a dictionary of styling parameters for the box's visual appearance.
@@ -152,14 +151,14 @@ class LogicBox:
             Dictionary containing styling properties for use with matplotlib text boxes.
         """
         my_style = {
-            'boxstyle': boxstyle,
-            'facecolor': facecolor,
-            'edgecolor': edgecolor,
-            'linewidth': linewidth
+            "boxstyle": boxstyle,
+            "facecolor": facecolor,
+            "edgecolor": edgecolor,
+            "linewidth": linewidth,
         }
 
         return my_style
-    
+
     def __repr__(self) -> str:
         """
         Return a developer-friendly string representation of the LogicBox.
@@ -173,5 +172,6 @@ class LogicBox:
             f"<LogicBox(name={self.name!r}, text={self.text!r}, "
             f"x={self.x}, y={self.y})>"
         )
-    
+
+
 __all__ = ["LogicBox"]
diff --git a/logictree/LogicTreeETC.py b/logictree/LogicTreeETC.py
index 444122d..1d7efb6 100644
--- a/logictree/LogicTreeETC.py
+++ b/logictree/LogicTreeETC.py
@@ -30,18 +30,19 @@ Here's a minimal example of how to build a logic tree diagram:
 
 Notes
 -----
-- ArrowETC connectors are limited to straight lines with right-angle bends (90-degree only).
 - If LaTeX rendering is enabled, packages such as bm, amsmath, soul, and relsize must be installed.
 """
 
-from typing import Any, Dict, List, Literal, Optional, Tuple
+from typing import Any, Dict, List, Literal, Optional, Tuple, Union
 
+from math import atan2, degrees
 from matplotlib.patches import BoxStyle
 import matplotlib.pyplot as plt
 
-from .ArrowETC import ArrowETC
+from arrowetc import ArrowETC
 from .LogicBoxETC import LogicBox
 
+
 class LogicTree:
     """
     Build logic tree diagrams by placing LogicBox objects and connecting them with ArrowETC arrows.
@@ -80,6 +81,8 @@ class LogicTree:
         The main matplotlib axes for drawing.
     boxes : dict
         Dictionary storing LogicBox objects keyed by their `box_name`.
+    arrows : list[ArrowETC]
+        List storing all ArrowETC objects.
     title : str
         The figure's title.
     xlims, ylims : tuple of float
@@ -91,62 +94,66 @@ class LogicTree:
     latex_ul_depth, latex_ul_width : str
         Settings for LaTeX underlining (depth and width).
     """
+
     def __init__(
         self,
         fig_size: Tuple[float, float] = (9, 9),
         xlims: Tuple[float, float] = (0, 100),
         ylims: Tuple[float, float] = (0, 100),
-        fig_fc: str = 'black',
+        fig_fc: str = "black",
         title: Optional[str] = None,
         font_dict: Optional[Dict[str, Any]] = None,
         font_dict_title: Optional[Dict[str, Any]] = None,
         text_color: Optional[str] = None,
         title_color: Optional[str] = None,
     ) -> None:
-        self.boxes = {}  
+        self.boxes: Dict[str, LogicBox] = {}
+        self.arrows: List[ArrowETC] = []
         self.title = title
         self.xlims = xlims
         self.ylims = ylims
-        
+
         # Font dictionary for title
         if font_dict_title is None:
-            font_dict_title = dict(fontname='Times New Roman', fontsize=34, color='white')
+            font_dict_title = dict(
+                fontname="Times New Roman", fontsize=34, color="white"
+            )
         if title_color is not None:
-            font_dict_title['color'] = title_color
+            font_dict_title["color"] = title_color
         self.title_font = font_dict_title
-        
+
         # Default font dictionary for boxes
         if font_dict is None:
             font_dict = {
-                'fontname': 'Times New Roman',
-                'fontsize': 15,
-                'color': 'white'
+                "fontname": "Times New Roman",
+                "fontsize": 15,
+                "color": "white",
             }
         if text_color is not None:
-            font_dict['color'] = text_color
+            font_dict["color"] = text_color
         self.font_dict = font_dict
-        
+
         # Underlining options for LaTeX rendering
-        self.latex_ul_depth = '1pt'
-        self.latex_ul_width = '1pt'
-        
+        self.latex_ul_depth = "1pt"
+        self.latex_ul_width = "1pt"
+
         # Generate figure and axes
         fig, ax = plt.subplots(figsize=fig_size, frameon=True, facecolor=fig_fc)
         ax.set_xlim(xlims[0], xlims[1])
         ax.set_ylim(ylims[0], ylims[1])
-        ax.axis('off')
+        ax.axis("off")
         fig.canvas.draw_idle()
-        
+
         self.fig = fig
         self.ax = ax
-        
+
     def _get_pathsForBi_left_then_right(
-        self, 
-        Ax2: float, 
-        Ay2: float, 
-        left_box: LogicBox, 
-        right_box: LogicBox, 
-        tip_offset: float
+        self,
+        Ax2: float,
+        Ay2: float,
+        left_box: LogicBox,
+        right_box: LogicBox,
+        tip_offset: float,
     ) -> Tuple[List[Tuple[float, float]], List[Tuple[float, float]]]:
         """
         Generate the paths for a bifurcating connection with left and right branches.
@@ -167,50 +174,83 @@ class LogicTree:
         -------
         tuple of list of tuple
             Paths for the left and right connections, each a list of (x, y) points.
+
+        Raises
+        ------
+        ValueError
+            If `yTop`, `yBottom`, xCenter or `yCenter` are None because the layout has
+            not yet been initialized. This is for either left_box or right_box.
         """
+        if (
+            left_box.yTop is None
+            or left_box.yBottom is None
+            or left_box.xCenter is None
+            or left_box.yCenter is None
+        ):
+            raise ValueError(
+                "left_box LogicBox layout not initialized before accessing coordinates."
+            )
+        if (
+            right_box.yTop is None
+            or right_box.yBottom is None
+            or right_box.xCenter is None
+            or right_box.yCenter is None
+        ):
+            raise ValueError(
+                "right_box LogicBox layout not initialized before accessing coordinates."
+            )
+
         # create the leftward arrow
         Lx1 = Ax2
         Ly1 = Ay2
-        Lx2 = left_box.x_center
+        Lx2 = left_box.xCenter
         Ly2 = Ly1
         Lx3 = Lx2
-        Ly3 = left_box.yTop + tip_offset if Ay2 > left_box.y_center else left_box.yBottom - tip_offset
-        
+        Ly3 = (
+            left_box.yTop + tip_offset
+            if Ay2 > left_box.yCenter
+            else left_box.yBottom - tip_offset
+        )
+
         # create the rightward arrow
         Rx1 = Ax2
         Ry1 = Ay2
-        Rx2 = right_box.x_center
+        Rx2 = right_box.xCenter
         Ry2 = Ry1
         Rx3 = Rx2
-        Ry3 = right_box.yTop + tip_offset if Ay2 > right_box.y_center else right_box.yBottom - tip_offset
+        Ry3 = (
+            right_box.yTop + tip_offset
+            if Ay2 > right_box.yCenter
+            else right_box.yBottom - tip_offset
+        )
 
         # set paths
         path_left = [(Lx1, Ly1), (Lx2, Ly2), (Lx3, Ly3)]
         path_right = [(Rx1, Ry1), (Rx2, Ry2), (Rx3, Ry3)]
 
-        return path_left, path_right    
+        return path_left, path_right
 
     def add_box(
-        self, 
-        xpos: float, 
-        ypos: float, 
-        text: str, 
-        box_name: str, 
-        bbox_fc: str, 
-        bbox_ec: str, 
+        self,
+        xpos: float,
+        ypos: float,
+        text: str,
+        box_name: str,
+        bbox_fc: str,
+        bbox_ec: str,
         font_dict: Optional[Dict[str, Any]] = None,
-        text_color: Optional[str] = None, 
-        fs: Optional[int] = None, 
-        font_weight: Optional[float] = None, 
+        text_color: Optional[str] = None,
+        fs: Optional[int] = None,
+        font_weight: Optional[float] = None,
         lw: float = 1.6,
-        bbox_style: BoxStyle = BoxStyle('Round', pad=0.6), 
-        va: Literal['top', 'center', 'bottom'] = 'center', 
-        ha: Literal['left', 'center', 'right'] = 'right', 
-        use_tex_rendering: bool = False, 
-        ul: bool = False, 
+        bbox_style: BoxStyle = BoxStyle("Round", pad=0.6),
+        va: Literal["top", "center", "bottom"] = "center",
+        ha: Literal["left", "center", "right"] = "right",
+        use_tex_rendering: bool = False,
+        ul: bool = False,
         ul_depth_width: Optional[Tuple[float, float]] = None,
-        angle: float = 0.0
-    ) -> None:
+        angle: float = 0.0,
+    ) -> LogicBox:
         """
         Add a LogicBox to the LogicTree with specified text and styling.
 
@@ -249,13 +289,22 @@ class LogicTree:
         angle : float, optional
             Angle in degrees to rotate your box. Rotations are about the center of the box.
 
+        Returns
+        -------
+        LogicBox
+            The new LogicBox object.
+
         Raises
         ------
         ValueError
             If `box_name` is already used.
+        ValueError
+            If the rendered text object has no bounding box patch.
         """
         if box_name in self.boxes:
-            raise ValueError(f"Box name '{box_name}' already exists. Please use a unique name.")
+            raise ValueError(
+                f"Box name '{box_name}' already exists. Please use a unique name."
+            )
 
         # option to use latex rendering (minimal font options with latex, so not default)
         if use_tex_rendering:
@@ -271,397 +320,1030 @@ class LogicTree:
             )
 
             # update rcParams to use latex
-            plt.rcParams.update({
-                "text.usetex": True,
-                "font.family": "cm",
-                'text.latex.preamble': latex_preamble
-            })
+            plt.rcParams.update(
+                {
+                    "text.usetex": True,
+                    "font.family": "cm",
+                    "text.latex.preamble": latex_preamble,
+                }
+            )
         else:
             plt.rcParams.update({"text.usetex": False})
-            
+
         # set fontidct of not provided
         if font_dict is None:
             font_dict = self.font_dict.copy()
         # if specific text color is specified, change it in font_dict
         if text_color is not None:
-            font_dict['color'] = text_color
+            font_dict["color"] = text_color
         # if specific fontsize is specified, change it in font_dict
         if fs is not None:
-            font_dict['fontsize'] = fs
+            font_dict["fontsize"] = fs
         # if weight is specified, change it in font_dict
         if font_weight is not None:
-            font_dict['weight'] = font_weight
-            
+            font_dict["weight"] = font_weight
+
         # create a logicBox object which stores all of this information
         myBox = LogicBox(
-            xpos=xpos, ypos=ypos, text=text, box_name=box_name, 
-            bbox_fc=bbox_fc, bbox_ec=bbox_ec, bbox_style=bbox_style, 
-            font_dict=font_dict, va=va, ha=ha, lw=lw, angle=angle
+            xpos=xpos,
+            ypos=ypos,
+            text=text,
+            box_name=box_name,
+            bbox_fc=bbox_fc,
+            bbox_ec=bbox_ec,
+            bbox_style=bbox_style,
+            font_dict=font_dict,
+            va=va,
+            ha=ha,
+            lw=lw,
+            angle=angle,
         )
-        
-        # add latex commands to text for underlining 
+
+        # add latex commands to text for underlining
         if use_tex_rendering and (ul or ul_depth_width is not None):
-            text_str = r'\ul{' + myBox.text + r'}'
+            text_str = r"\ul{" + myBox.text + r"}"
             # if underlining parameters are set, add the command to change them
             if ul_depth_width is not None:
-                text_str = f'\\setul{{{ul_depth_width[0]}}}{{{ul_depth_width[1]}}}' + text_str
+                text_str = (
+                    r"\setul{"
+                    + f"{ul_depth_width[0]}pt"
+                    + r"}{"
+                    + f"{ul_depth_width[1]}pt"
+                    + r"}"
+                    + text_str
+                )
         else:
             text_str = myBox.text
         # make the text
         txt = self.ax.text(
-            x=myBox.x, y=myBox.y, s=text_str, fontdict=myBox.font_dict,
-            bbox=myBox.style, va=myBox.va, ha=myBox.ha, rotation=myBox.angle
+            x=myBox.x,
+            y=myBox.y,
+            s=text_str,
+            fontdict=myBox.font_dict,
+            bbox=myBox.style,
+            va=myBox.va,
+            ha=myBox.ha,
+            rotation=myBox.angle,
         )
-        
-        # get our box's dims and edge positions to store in myBox object
-        bbox = plt.gca().transData.inverted().transform_bbox(
-            txt.get_window_extent(renderer=self.fig.canvas.get_renderer())
-        ) # coords of text
-        wpad = txt.get_bbox_patch().get_extents().width # pad size for width
-        hpad = txt.get_bbox_patch().get_extents().height # pad size for height
-        myBox.xLeft, myBox.xRight = bbox.x0 - wpad, bbox.x1 + wpad
-        myBox.yBottom, myBox.yTop = bbox.y0 - hpad, bbox.y1 + wpad
+
+        # Ensure the figure is rendered so bbox extents are valid
+        self.fig.canvas.draw()
+
+        # Get the full bounding box of the text box (includes padding and styling)
+        bbox_patch = txt.get_bbox_patch()
+        if bbox_patch is None:
+            raise ValueError("Text object has no bounding box patch.")
+
+        # Convert the patch bbox from display to data coordinates
+        bbox_data = self.ax.transData.inverted().transform_bbox(
+            bbox_patch.get_window_extent(renderer=self.fig.canvas.get_renderer())  # type: ignore
+        )
+
+        # Set box dimensions and positions
+        myBox.xLeft, myBox.xRight = bbox_data.x0, bbox_data.x1
+        myBox.yBottom, myBox.yTop = bbox_data.y0, bbox_data.y1
         myBox.width = myBox.xRight - myBox.xLeft
         myBox.height = myBox.yTop - myBox.yBottom
-        myBox.x_center = myBox.xRight - myBox.width/2
-        myBox.y_center = myBox.yTop - myBox.height/2
-        
+        myBox.xCenter = (myBox.xLeft + myBox.xRight) / 2
+        myBox.yCenter = (myBox.yBottom + myBox.yTop) / 2
+
         # store box in our LogicTree object's box dictionary to grab dimensions when needed
         self.boxes[myBox.name] = myBox
-        
+
+        return myBox
+
+    def add_arrow(self, arrow: ArrowETC) -> None:
+        """
+        Add a pre-constructed ArrowETC object to the LogicTree canvas.
+
+        This method allows advanced users to configure complex arrows externally
+        and then attach them to the logic tree. The arrow is stored for later access
+        and drawn using the existing matplotlib axes.
+
+        Parameters
+        ----------
+        arrow : ArrowETC
+            A ready-to-render ArrowETC object.
+
+        Raises
+        ------
+        ValueError
+            If the ArrowETC object is missing a valid path.
+        """
+        if not arrow.path or len(arrow.path) < 2:
+            raise ValueError("ArrowETC must have a path with at least two points.")
+
+        self.arrows.append(arrow)
+        self.ax = arrow.draw_to_ax(self.ax)
+
+    def add_arrow_between(
+        self,
+        start: tuple[float, float],
+        end: tuple[float, float],
+        arrow_width: float = 0.5,
+        arrow_head: bool = True,
+        bezier: bool = False,
+        tip_offset: float = 0.0,
+        butt_offset: float = 0.0,
+        facecolor: str = "black",
+        edgecolor: str = "black",
+        alpha: float = 1.0,
+        zorder: float = 1.0,
+        linewidth: float = 1.0,
+        linestyle: str = "-",
+    ) -> None:
+        """
+        Add a quick arrow between two points using default ArrowETC settings.
+
+        This wrapper creates a new ArrowETC object from two coordinates and adds it
+        to the logic tree. Useful for free-floating annotations or diagram embellishment.
+
+        Parameters
+        ----------
+        start : tuple of float
+            (x, y) coordinates for the base of the arrow.
+        end : tuple of float
+            (x, y) coordinates for the tip of the arrow.
+        arrow_width : float, optional
+            Width of the arrow shaft. Default is 0.5.
+        arrow_head : bool, optional
+            Whether to draw an arrowhead. Default is True.
+        bezier : bool, optional
+            Whether to render the arrow as a Bezier curve. Default is False.
+        tip_offset : float, optional
+            Distance to offset the arrow tip (e.g., to avoid overlap). Default is 0.0.
+        butt_offset : float, optional
+            Distance to offset the arrow base. Default is 0.0.
+        facecolor : str, optional
+            Fill color of the arrow. Default is "black".
+        edgecolor : str, optional
+            Outline color of the arrow. Default is "black".
+        alpha : float, optional
+            Opacity of the arrow. Default is 1.0.
+        zorder : float, optional
+            Drawing layer priority. Default is 1.0.
+        linewidth : float, optional
+            Outline thickness. Default is 1.0.
+        linestyle : str, optional
+            Line style (e.g., "-", "--"). Default is "-".
+
+        Raises
+        ------
+        ValueError
+            If start and end points are the same.
+        """
+        if start == end:
+            raise ValueError("Arrow start and end points must differ.")
+
+        path = [start, end]
+        arrow = ArrowETC(
+            path=path,
+            arrow_width=arrow_width,
+            arrow_head=arrow_head,
+            bezier=bezier,
+            tip_offset=tip_offset,
+            butt_offset=butt_offset,
+            facecolor=facecolor,
+            edgecolor=edgecolor,
+            alpha=alpha,
+            zorder=zorder,
+            linewidth=linewidth,
+            linestyle=linestyle,
+        )
+        self.add_arrow(arrow)
+
     def add_connection_biSplit(
-        self, 
-        boxA: LogicBox, 
-        boxB: LogicBox, 
-        boxC: LogicBox, 
-        arrow_head: bool = True, 
+        self,
+        boxA: LogicBox,
+        boxB: LogicBox,
+        boxC: LogicBox,
+        arrow_head: bool = True,
         arrow_width: float = 0.5,
-        fill_connection: bool = True, 
-        fc_A: Optional[str] = None, 
-        ec_A: Optional[str] = None, 
-        fc_B: Optional[str] = None, 
+        fill_connection: bool = True,
+        fc_A: Optional[str] = None,
+        ec_A: Optional[str] = None,
+        fc_B: Optional[str] = None,
         ec_B: Optional[str] = None,
-        fc_C: Optional[str] = None, 
-        ec_C: Optional[str] = None, 
-        lw: float = 0.5, 
-        butt_offset: float = 0, 
-        tip_offset: float = 0
+        fc_C: Optional[str] = None,
+        ec_C: Optional[str] = None,
+        lw: float = 0.5,
+        butt_offset: float = 0,
+        tip_offset: float = 0,
+        textLeft: Optional[str] = None,
+        textRight: Optional[str] = None,
+        textLeftOffset: Literal["above", "below"] = "above",
+        textRightOffset: Literal["above", "below"] = "above",
+        text_kwargs: Optional[dict] = None,
     ) -> None:
         """
-        Create a bifurcating connection from boxA to both boxB and boxC.
+        Create a bifurcating arrow connection from a parent LogicBox (`boxA`) to two child boxes (`boxB` and `boxC`),
+        using a stem that splits into two branching segments. Labels can optionally be placed along the left and right
+        arrow branches with customizable position and styling.
+
+        This method automatically infers the orientation of the bifurcation (downward or upward) based on the vertical
+        positions of the input boxes. It also determines the left/right ordering based on horizontal positions. Arrow
+        styling (head, width, fill, color) and label appearance are all configurable.
 
         Parameters
         ----------
-        boxA, boxB, boxC : LogicBox
-            Parent and child boxes for the connection. boxA must be above or below both boxB and boxC.
+        boxA : LogicBox
+            The parent box from which the bifurcation begins. Must be clearly vertically above or below both child boxes.
+        boxB : LogicBox
+            One of the two child boxes. The method will automatically determine whether this is the left or right branch
+            based on xCenter.
+        boxC : LogicBox
+            The other child box. Must be on the same vertical side of `boxA` as `boxB`.
         arrow_head : bool, optional
-            If True, draws arrowheads at boxB and boxC.
+            If True (default), draws arrowheads at the ends of the left and right branches.
         arrow_width : float, optional
-            Width of the arrows in data coordinates.
+            Width of the arrows in data units. Default is 0.5.
         fill_connection : bool, optional
-            Whether to fill the arrows with color.
-        fc_A, ec_A, fc_B, ec_B, fc_C, ec_C : str, optional
-            Fill and edge colors for the three parts of the connection.
+            Whether to fill the arrows with face color (True by default). If False, only outlines are drawn.
+        fc_A : str, optional
+            Face color of the vertical stem arrow from boxA. If None, defaults to `boxA.face_color`.
+            If "ec", uses `boxA.edge_color`.
+        ec_A : str, optional
+            Edge color of the vertical stem arrow from boxA. If None, defaults to `boxA.edge_color`.
+            If "fc", uses `boxA.face_color`.
+        fc_B : str, optional
+            Face color of the arrow branch toward boxB. If None, defaults to `boxB.face_color`.
+            If "ec", uses `boxB.edge_color`.
+        ec_B : str, optional
+            Edge color of the arrow branch toward boxB. If None, defaults to `boxB.edge_color`.
+            If "fc", uses `boxB.face_color`.
+        fc_C : str, optional
+            Face color of the arrow branch toward boxC. If None, defaults to `boxC.face_color`.
+            If "ec", uses `boxC.edge_color`.
+        ec_C : str, optional
+            Edge color of the arrow branch toward boxC. If None, defaults to `boxC.edge_color`.
+            If "fc", uses `boxC.face_color`.
         lw : float, optional
-            Line width of the arrows.
-        butt_offset, tip_offset : float, optional
-            Offsets for avoiding overlap at the base or tips of the arrows.
+            Line width of the arrow edges. Default is 0.5.
+        butt_offset : float, optional
+            Distance to offset the base of the vertical stem away from the parent boxA. Prevents visual overlap.
+            Default is 0.
+        tip_offset : float, optional
+            Distance to offset the tips of the arrows from boxB and boxC. Prevents overlap with box edges.
+            Default is 0.
+        textLeft : str, optional
+            Optional text label to display above or below the arrow leading to the left box. Centered along the shaft.
+        textRight : str, optional
+            Optional text label to display above or below the arrow leading to the right box. Centered along the shaft.
+        textLeftOffset : {'above', 'below'}, optional
+            Whether to place the `textLeft` label above or below the arrow shaft. Default is 'above'.
+        textRightOffset : {'above', 'below'}, optional
+            Whether to place the `textRight` label above or below the arrow shaft. Default is 'above'.
+        text_kwargs : dict, optional
+            Dictionary of matplotlib-compatible text styling options. Keys may include:
+                - 'fontsize' (int): font size (default: 12)
+                - 'fontname' (str): font family (default: 'sans-serif')
+                - 'color' (str): font color (default: 'white')
 
         Raises
         ------
         ValueError
-            If boxA is not clearly above or below both boxB and boxC.
+            If any required coordinates (`xLeft`, `xCenter`, `xRight`, `yTop`, `yCenter`, `yBottom`) of any input box
+            are uninitialized (i.e., None).
+
+        ValueError
+            If `boxA` is not clearly vertically above or below both `boxB` and `boxC`.
+
+        Notes
+        -----
+        This function is intended for use with properly initialized `LogicBox` instances, such as those added via
+        LogicTree's `add_box()` method. It is useful for visualizing binary decision splits in flow diagrams or logic trees.
         """
-        # do stylizing stuff
-        if fill_connection:
-            # option for face color to equal edgecolor
-            if fc_A == 'ec':
-                fc_A = boxA.edge_color
-            # if no option specified, face color of arrow is same as face color of box
-            elif fc_A is None:
-                fc_A = boxA.face_color
-            # option for face color to equal edgecolor
-            if fc_B == 'ec':
-                fc_B = boxB.edge_color
-            # if no option specified, face color of arrow is same as face color of box
-            elif fc_B is None:
-                fc_B = boxB.face_color
-            # option for face color to equal edgecolor
-            if fc_C == 'ec':
-                fc_C = boxC.edge_color
-            # if no option specified, face color of arrow is same as face color of box
-            elif fc_C is None:
-                fc_C = boxC.face_color
-        
-        if ec_A =='fc':
-            ec_A = boxA.face_color
-        elif ec_A is None:
-            ec_A = boxA.edge_color
-        if ec_B =='fc':
-            ec_B = boxB.face_color
-        elif ec_B is None:
-            ec_B = boxB.edge_color
-        if ec_C =='fc':
-            ec_C = boxC.face_color
-        elif ec_C is None:
-            ec_C = boxC.edge_color
-        
-        # first take the case of boxA being above boxes B and C
-        if (boxA.y_center > boxB.y_center) and (boxA.y_center > boxC.y_center):
-            # create the downward line from BoxA to center
-            Ax1 = boxA.x_center
-            Ay1 = boxA.yBottom - butt_offset
-            Ax2 = Ax1
-            # take it down to the midpoint of boxA and the highest of boxes B and C
-            if boxB.yTop >= boxC.yTop:
-                Ay2 = (Ay1 + boxB.yTop)/2
-            else:
-                Ay2 = (Ay1 + boxC.yTop)/2
-            # set path for downward segment
-            path = [(Ax1, Ay1), (Ax2, Ay2)]
-            arrow = ArrowETC(path=path, arrow_head=False, arrow_width=arrow_width)
-
-            # get vertices
-            x = arrow.x_vertices[:-1]
-            y = arrow.y_vertices[:-1]
-            self.ax.plot(x, y, color=ec_A, lw=0.01)
-            # fill arrow if desired
-            if fill_connection:
-                self.ax.fill(x, y, color=fc_A)
-                
-            # take the case that boxB is to the left of boxC 
-            if boxB.x_center < boxC.x_center:
-                # get paths
-                path_left, path_right = self._get_pathsForBi_left_then_right(Ax2, Ay2, left_box=boxB, \
-                                                                             right_box=boxC, tip_offset=tip_offset)
-                # make left arrow
-                arrow = ArrowETC(path=path_left, arrow_head=arrow_head, arrow_width=arrow_width)
-                # get vertices
-                x = arrow.x_vertices[:-1]
-                y = arrow.y_vertices[:-1]
-                self.ax.plot(x, y, color=ec_B, lw=lw)
-                # fill arrow if desired
-                if fill_connection:
-                    self.ax.fill(x, y, color=fc_B)
-                
-                # make right arrow
-                arrow = ArrowETC(path=path_right, arrow_head=arrow_head, arrow_width=arrow_width)
-                # get vertices
-                x = arrow.x_vertices[:-1]
-                y = arrow.y_vertices[:-1]
-                self.ax.plot(x, y, color=ec_C, lw=lw)
-                # fill arrow if desired
-                if fill_connection:
-                    self.ax.fill(x, y, color=fc_C)
-                    
-            # take the case that boxB is to the right of boxC 
-            elif boxB.x_center > boxC.x_center:
-                # get paths
-                path_left, path_right = self._get_pathsForBi_left_then_right(Ax2, Ay2, left_box=boxC, right_box=boxB, tip_offset=tip_offset)
-                # make left arrow
-                arrow = ArrowETC(path=path_left, arrow_head=arrow_head, arrow_width=arrow_width)
-                # get vertices
-                x = arrow.x_vertices[:-1]
-                y = arrow.y_vertices[:-1]
-                self.ax.plot(x, y, color=ec_C, lw=lw)
-                # fill arrow if desired
-                if fill_connection:
-                    self.ax.fill(x, y, color=fc_C)
-                
-                # make right arrow
-                arrow = ArrowETC(path=path_right, arrow_head=arrow_head, arrow_width=arrow_width)
-                # get vertices
-                x = arrow.x_vertices[:-1]
-                y = arrow.y_vertices[:-1]
-                self.ax.plot(x, y, color=ec_B, lw=lw)
-                # fill arrow if desired
-                if fill_connection:
-                    self.ax.fill(x, y, color=fc_B)
-                
-        # now take the case of boxA being below boxes B and C
-        elif (boxA.y_center < boxB.y_center) and (boxA.y_center < boxC.y_center):
-            # create the upward line from BoxA to center
-            Ax1 = boxA.x_center
-            Ay1 = boxA.yTop + butt_offset
-            Ax2 = Ax1
-            # take it down to the midpoint of boxA and the highest of boxes B and C
-            if boxB.yBottom <= boxC.yBottom:
-                Ay2 = (Ay1 + boxB.yBottom)/2
-            else:
-                Ay2 = (Ay1 + boxC.yBottom)/2
-            # set path for downward segment
-            path = [(Ax1, Ay1), (Ax2, Ay2)]
-            arrow = ArrowETC(path=path, arrow_head=arrow_head, arrow_width=arrow_width)
-
-            # get vertices
-            x = arrow.x_vertices[:-1]
-            y = arrow.y_vertices[:-1]
-            self.ax.plot(x, y, color=ec_A, lw=0.01)
-            # fill arrow if desired
+
+        if (
+            boxA.xLeft is None
+            or boxA.xCenter is None
+            or boxA.xRight is None
+            or boxA.yTop is None
+            or boxA.yCenter is None
+            or boxA.yBottom is None
+        ):
+            raise ValueError(
+                "boxA LogicBox layout is not initialized before accessing coordinates."
+            )
+        if (
+            boxB.xLeft is None
+            or boxB.xCenter is None
+            or boxB.xRight is None
+            or boxB.yTop is None
+            or boxB.yCenter is None
+            or boxB.yBottom is None
+        ):
+            raise ValueError(
+                "boxB LogicBox layout is not initialized before accessing coordinates."
+            )
+        if (
+            boxC.xLeft is None
+            or boxC.xCenter is None
+            or boxC.xRight is None
+            or boxC.yTop is None
+            or boxC.yCenter is None
+            or boxC.yBottom is None
+        ):
+            raise ValueError(
+                "boxC LogicBox layout is not initialized before accessing coordinates."
+            )
+
+        # Resolve text styling
+        if text_kwargs is None:
+            text_kwargs = {}
+        fontname = text_kwargs.get("fontname", "sans-serif")
+        fontsize = text_kwargs.get("fontsize", 12)
+        fontcolor = text_kwargs.get("color", "white")
+
+        def annotate_segment(
+            text: Optional[str],
+            path: list[tuple[float, float]],
+            offset: Literal["above", "below"],
+        ) -> None:
+            """
+            Place text at the midpoint of a given arrow segment, offset vertically above or below.
+
+            Parameters
+            ----------
+            text : str, optional
+                The text to render. If None or empty, nothing is drawn.
+            path : list of (float, float)
+                The path representing the arrow segment.
+            offset : {'above', 'below'}
+                Whether the label is placed above or below the arrow shaft.
+            """
+            if not text:
+                return
+            (x1, y1), (x2, _) = path[0], path[-1]
+            xm = (x1 + x2) / 2 + (arrow_width / 2 if x1 < x2 else -arrow_width / 2)
+            ym = (
+                y1 + arrow_width * 0.95
+                if offset == "above"
+                else y1 - arrow_width * 0.95
+            )
+            va = "bottom" if offset == "above" else "top"
+            self.ax.text(
+                xm,
+                ym,
+                text,
+                ha="center",
+                va=va,
+                fontsize=fontsize,
+                fontname=fontname,
+                color=fontcolor,
+            )
+
+        def resolve_colors(
+            box: LogicBox, fc: Optional[str], ec: Optional[str]
+        ) -> tuple[Optional[str], str]:
+            """
+            Resolve fill and edge color settings using box defaults and shorthand keywords.
+
+            Parameters
+            ----------
+            box : LogicBox
+                The box used to provide default or fallback colors.
+            fc : str, optional
+                The face color. Can be None, "ec", or a valid color string.
+            ec : str, optional
+                The edge color. Can be None, "fc", or a valid color string.
+
+            Returns
+            -------
+            tuple of (str, str)
+                The resolved face color and edge color.
+            """
             if fill_connection:
-                self.ax.fill(x, y, color=fc_A)
-
-            # take the case that boxB is to the left of boxC 
-            if boxB.x_center < boxC.x_center:
-                # get paths
-                path_left, path_right = self._get_pathsForBi_left_then_right(Ax2, Ay2, left_box=boxB, \
-                                                                             right_box=boxC, tip_offset=tip_offset)
-                # make left arrow
-                arrow = ArrowETC(path=path_left, arrow_head=arrow_head, arrow_width=arrow_width)
-                # get vertices
-                x = arrow.x_vertices[:-1]
-                y = arrow.y_vertices[:-1]
-                self.ax.plot(x, y, color=ec_B, lw=lw)
-                # fill arrow if desired
-                if fill_connection:
-                    self.ax.fill(x, y, color=fc_B)
-                
-                # make right arrow
-                arrow = ArrowETC(path=path_right, arrow_head=arrow_head, arrow_width=arrow_width)
-                # get vertices
-                x = arrow.x_vertices[:-1]
-                y = arrow.y_vertices[:-1]
-                self.ax.plot(x, y, color=ec_C, lw=lw)
-                # fill arrow if desired
-                if fill_connection:
-                    self.ax.fill(x, y, color=fc_C)
-                    
-            # take the case that boxB is to the right of boxC 
-            elif boxB.x_center > boxC.x_center:
-                # get paths
-                path_left, path_right = self._get_pathsForBi_left_then_right(Ax2, Ay2, left_box=boxC, right_box=boxB, tip_offset=tip_offset)
-                # make left arrow
-                arrow = ArrowETC(path=path_left, arrow_head=arrow_head, arrow_width=arrow_width)
-                # get vertices
-                x = arrow.x_vertices[:-1]
-                y = arrow.y_vertices[:-1]
-                self.ax.plot(x, y, color=ec_C, lw=lw)
-                # fill arrow if desired
-                if fill_connection:
-                    self.ax.fill(x, y, color=fc_C)
-                
-                # make right arrow
-                arrow = ArrowETC(path=path_right, arrow_head=arrow_head, arrow_width=arrow_width)
-                # get vertices
-                x = arrow.x_vertices[:-1]
-                y = arrow.y_vertices[:-1]
-                self.ax.plot(x, y, color=ec_B, lw=lw)
-                # fill arrow if desired
-                if fill_connection:
-                    self.ax.fill(x, y, color=fc_B)
-            
+                fc = (
+                    box.edge_color
+                    if fc == "ec"
+                    else (box.face_color if fc is None else fc)
+                )
+            ec = (
+                box.face_color if ec == "fc" else (box.edge_color if ec is None else ec)
+            )
+
+            return fc, ec
+
+        fc_A, ec_A = resolve_colors(boxA, fc_A, ec_A)
+        fc_B, ec_B = resolve_colors(boxB, fc_B, ec_B)
+        fc_C, ec_C = resolve_colors(boxC, fc_C, ec_C)
+
+        # Determine vertical direction of arrows
+        if boxA.yCenter > boxB.yCenter and boxA.yCenter > boxC.yCenter:
+            Ax1, Ay1 = boxA.xCenter, boxA.yBottom - butt_offset
+            Ay2 = (Ay1 + max(boxB.yTop, boxC.yTop)) / 2
+        elif boxA.yCenter < boxB.yCenter and boxA.yCenter < boxC.yCenter:
+            Ax1, Ay1 = boxA.xCenter, boxA.yTop + butt_offset
+            Ay2 = (Ay1 + min(boxB.yBottom, boxC.yBottom)) / 2
+        else:
+            raise ValueError("boxA must be clearly above or below both boxB and boxC.")
+
+        Ax2 = Ax1
+        path_vertical = [(Ax1, Ay1), (Ax2, Ay2)]
+        arrow = ArrowETC(
+            path=path_vertical,
+            arrow_head=False,
+            arrow_width=arrow_width,
+            ec=ec_A,
+            fc=fc_A,
+            lw=lw,
+        )
+        self.add_arrow(arrow)
+
+        # Determine left/right order
+        left_box, right_box = (
+            (boxB, boxC) if boxB.xCenter < boxC.xCenter else (boxC, boxB)
+        )
+        path_left, path_right = self._get_pathsForBi_left_then_right(
+            Ax2, Ay2, left_box=left_box, right_box=right_box, tip_offset=tip_offset
+        )
+
+        def draw_branch(
+            path: list[tuple[float, float]],
+            ec: str,
+            fc: Optional[str],
+            lw: float,
+            label: Optional[str],
+            label_offset: Literal["above", "below"],
+        ) -> None:
+            """
+            Draw a single arrow branch with optional fill and text annotation.
+
+            Parameters
+            ----------
+            path : list of (float, float)
+                The arrow path from the split point to the destination box.
+            ec : str
+                Edge color of the arrow.
+            fc : str
+                Fill color of the arrow.
+            label : str, optional
+                Optional text to annotate the arrow shaft.
+            label_offset : {'above', 'below'}
+                Vertical position of the text relative to the arrow shaft.
+            """
+            arrow = ArrowETC(
+                path=path,
+                arrow_head=arrow_head,
+                arrow_width=arrow_width,
+                ec=ec,
+                fc=fc,
+                lw=lw,
+                close_butt=False,
+                zorder=1000,
+            )
+            self.add_arrow(arrow)
+            annotate_segment(label, path, label_offset)
+
+        # Draw left
+        if left_box is boxB:
+            draw_branch(path_left, ec_B, fc_B, lw, textLeft, textLeftOffset)
+            draw_branch(path_right, ec_C, fc_C, lw, textRight, textRightOffset)
+        else:
+            draw_branch(path_left, ec_C, fc_C, lw, textLeft, textLeftOffset)
+            draw_branch(path_right, ec_B, fc_B, lw, textRight, textRightOffset)
+
+    def _get_side_coords(
+        self, box: LogicBox, side: str, offset: float = 0.0
+    ) -> tuple[float, float]:
+        """
+        Return coordinates on a box edge or corner, optionally nudged outward.
+
+        Parameters
+        ----------
+        box : LogicBox
+            The box to extract a coordinate from.
+        side : str
+            One of 'left', 'right', 'top', 'bottom', 'center', or a corner like 'topLeft'.
+        offset : float, optional
+            Distance to offset the point outward in the direction of connection.
+        """
+        if (
+            box.xLeft is None
+            or box.xCenter is None
+            or box.xRight is None
+            or box.yTop is None
+            or box.yCenter is None
+            or box.yBottom is None
+        ):
+            raise ValueError(
+                "box LogicBox layout is not initialized before accessing coordinates."
+            )
+
+        match side:
+            case "left":
+                return box.xLeft - offset, box.yCenter
+            case "right":
+                return box.xRight + offset, box.yCenter
+            case "top":
+                return box.xCenter, box.yTop + offset
+            case "bottom":
+                return box.xCenter, box.yBottom - offset
+            case "center":
+                return box.xCenter, box.yCenter
+            case "topLeft":
+                return box.xLeft - offset, box.yTop + offset
+            case "topRight":
+                return box.xRight + offset, box.yTop + offset
+            case "bottomLeft":
+                return box.xLeft - offset, box.yBottom - offset
+            case "bottomRight":
+                return box.xRight + offset, box.yBottom - offset
+            case _:
+                raise ValueError(f"Invalid side: '{side}'")
+
     def add_connection(
-        self, 
-        boxA: LogicBox, 
-        boxB: LogicBox, 
-        arrow_head: bool = True, 
-        arrow_width: float = 0.5, 
-        fill_connection: bool= True,
-        butt_offset: float = 0, 
-        tip_offset: float = 0, 
-        fc: Optional[str] = None, 
-        ec: Optional[str] = None, 
-        lw: float = 0.7
+        self,
+        boxA: LogicBox,
+        boxB: Union[LogicBox, Tuple[float, float]],
+        segmented: bool = False,
+        arrow_head: bool = True,
+        arrow_width: float = 0.5,
+        fill_connection: bool = True,
+        butt_offset: float = 0,
+        tip_offset: float = 0,
+        fc: Optional[str] = None,
+        ec: Optional[str] = None,
+        lw: float = 0.7,
+        sideA: Optional[
+            Literal[
+                "left",
+                "topLeft",
+                "top",
+                "topRight",
+                "right",
+                "bottomRight",
+                "bottom",
+                "bottomLeft",
+                "center",
+            ]
+        ] = None,
+        sideB: Optional[
+            Literal[
+                "left",
+                "topLeft",
+                "top",
+                "topRight",
+                "right",
+                "bottomRight",
+                "bottom",
+                "bottomLeft",
+                "center",
+            ]
+        ] = None,
     ) -> None:
         """
-        Create a straight or segmented connection (arrow) from boxA to boxB.
+        Draw a straight or segmented arrow connection between two LogicBoxes.
+
+        The arrow can be automatically routed or user-directed by specifying entry and
+        exit sides (edges or corners). Optional offsets ensure that arrows avoid overlap
+        with box borders.
 
         Parameters
         ----------
-        boxA, boxB : LogicBox
-            Source and target boxes for the connection.
+        boxA : LogicBox
+            The source LogicBox from which the arrow originates.
+        boxB : LogicBox | Tuple[float, float]
+            The target LogicBox, or the exact coordinates (x, y) to which the arrow points. If you want
+            padding between the point (or LogicBox edge), update the `tip_offset` parameter.
+        segmented : bool, optional
+            If True, non-aligned boxes will be connected with segmented (elbow) arrows.
+            If False, a direct connection is used. Default is False.
         arrow_head : bool, optional
-            If True, draws an arrowhead at boxB.
+            Whether to draw an arrowhead pointing at `boxB`. Default is True.
         arrow_width : float, optional
-            Width of the arrow in data coordinates. Default is 0.5.
+            Width of the arrow shaft in data units. Default is 0.5.
         fill_connection : bool, optional
-            Whether to fill the arrow with color.
+            Whether to fill the arrow body with color. Default is True.
         butt_offset : float, optional
-            Offset of the arrow's butt to avoid overlapping with boxA.
+            Distance to offset the starting point of the arrow (away from `boxA`) in the
+            direction of the connection. Default is 0.
         tip_offset : float, optional
-            Offset of the arrow's tip to avoid overlapping with boxB.
+            Distance to offset the tip of the arrow (away from `boxB`) to avoid overlap.
+            Default is 0.
         fc : str, optional
-            Fill color; if None, uses boxB's face color. If 'ec', uses boxB's edge color.
+            Fill color of the arrow body. If None, uses `boxB`'s face color. If 'ec', uses `boxB`'s edge color.
         ec : str, optional
-            Edge color; if None, uses boxB's edge color. If 'fc', uses boxB's face color.
+            Edge color (outline) of the arrow. If None, uses `boxB`'s edge color. If 'fc', uses face color.
         lw : float, optional
-            Line width of the arrow edges.
+            Line width of the arrow outline. Default is 0.7.
+        sideA : {'left', 'topLeft', 'right', 'topRight', 'top', 'bottomRight', 'bottom', 'bottomLeft' 'center'}, optional
+            The side or corner of `boxA` where the arrow starts. Options include:
+            'left', 'right', 'top', 'bottom', 'center', 'topLeft', 'topRight', 'bottomLeft', 'bottomRight'.
+            If not provided, it is inferred automatically based on box positions.
+        sideB : {'left', 'topLeft', 'right', 'topRight', 'top', 'bottomRight', 'bottom', 'bottomLeft' 'center'}, optional
+            The side or corner of `boxB` where the arrow ends. Same options as `sideA`.
 
         Raises
         ------
         ValueError
-            If boxes are not aligned in the same row or column and cannot be connected directly.
+            If boxA and boxB have the same center position.
+        ValueError
+            If required box coordinates are not initialized.
         """
-        # handle colors
-        if fill_connection:
-            # if no fc is chosen, take the fc of connection to be fc of boxB
-            if fc is None or fc == 'fc':
-                fc = boxB.face_color
-            elif fc == 'ec':
-                fc = boxB.edge_color
-        # if no ec is chosen, take ec of connection to be ec of boxB
-        if ec is None or ec == 'ec':
-            ec = boxB.edge_color
-        elif ec == 'fc':
-            ec = boxB.face_color
-            
-        # first case, boxA and boxB are on the same row
-        if boxA.y_center == boxB.y_center:
-            # boxA is to the left of boxB
-            if boxA.x_center < boxB.x_center:
-                Ax, Ay = boxA.xRight + butt_offset, boxA.y_center
-                Bx, By = boxB.xLeft - tip_offset, boxB.y_center
-            # boxA is to the right of boxB
-            elif boxA.x_center > boxB.x_center:
-                Ax, Ay = boxA.xLeft - butt_offset, boxA.y_center
-                Bx, By = boxB.xRight + tip_offset, boxB.y_center
-            path = [(Ax, Ay), (Bx, By)]
-        # second case, boxA is below boxB
-        elif boxA.y_center < boxB.y_center:
-            # same column
-            if boxA.x_center == boxB.x_center:
-                Ax, Ay = boxA.x_center, boxA.yTop + butt_offset
-                Bx, By = boxB.x_center, boxB.yBottom - tip_offset
-                path = [(Ax, Ay), (Bx, By)]
-            # boxes are offset in the x-axis
+        if (
+            boxA.xLeft is None
+            or boxA.xCenter is None
+            or boxA.xRight is None
+            or boxA.yTop is None
+            or boxA.yCenter is None
+            or boxA.yBottom is None
+        ):
+            raise ValueError(
+                "boxA LogicBox layout is not initialized before accessing coordinates."
+            )
+
+        if isinstance(boxB, LogicBox):
+            if (
+                boxB.xLeft is None
+                or boxB.xCenter is None
+                or boxB.xRight is None
+                or boxB.yTop is None
+                or boxB.yCenter is None
+                or boxB.yBottom is None
+            ):
+                raise ValueError(
+                    "boxB LogicBox layout is not initialized before accessing coordinates."
+                )
+            if fill_connection:
+                if fc is None or fc == "fc":
+                    fc = boxB.face_color
+                elif fc == "ec":
+                    fc = boxB.edge_color
+            if ec is None or ec == "ec":
+                ec = boxB.edge_color
+            elif ec == "fc":
+                ec = boxB.face_color
+
+            if boxA.xCenter == boxB.xCenter and boxA.yCenter == boxB.yCenter:
+                raise ValueError("Boxes cannot have the same position.")
+
+            dx = boxB.xCenter - boxA.xCenter
+            dy = boxB.yCenter - boxA.yCenter
+        else:
+            # boxB is a coordinate point
+            xB, yB = boxB
+            dx = xB - boxA.xCenter
+            dy = yB - boxA.yCenter
+
+        theta = degrees(atan2(dy, dx))
+
+        def auto_side(theta: float, for_A: bool) -> str:
+            if -45 <= theta <= 45:
+                return "right" if for_A else "left"
+            elif 45 < theta <= 135:
+                return "top" if for_A else "bottom"
+            elif theta > 135 or theta < -135:
+                return "left" if for_A else "right"
+            else:
+                return "bottom" if for_A else "top"
+
+        resolved_sideA = sideA or auto_side(theta, for_A=True)
+        resolved_sideB = sideB or auto_side(theta, for_A=False)
+
+        start = self._get_side_coords(boxA, resolved_sideA)
+
+        if isinstance(boxB, LogicBox):
+            end = self._get_side_coords(boxB, resolved_sideB)
+        else:
+            end = boxB  # (x, y) tuple
+
+        if butt_offset:
+            match resolved_sideA:
+                case "left":
+                    start = (start[0] - butt_offset, start[1])
+                case "right":
+                    start = (start[0] + butt_offset, start[1])
+                case "top":
+                    start = (start[0], start[1] + butt_offset)
+                case "bottom":
+                    start = (start[0], start[1] - butt_offset)
+                case "topLeft":
+                    start = (start[0] - butt_offset, start[1] + butt_offset)
+                case "topRight":
+                    start = (start[0] + butt_offset, start[1] + butt_offset)
+                case "bottomLeft":
+                    start = (start[0] - butt_offset, start[1] - butt_offset)
+                case "bottomRight":
+                    start = (start[0] + butt_offset, start[1] - butt_offset)
+
+        if tip_offset:
+            match resolved_sideB:
+                case "left":
+                    end = (end[0] - tip_offset, end[1])
+                case "right":
+                    end = (end[0] + tip_offset, end[1])
+                case "top":
+                    end = (end[0], end[1] + tip_offset)
+                case "bottom":
+                    end = (end[0], end[1] - tip_offset)
+                case "topLeft":
+                    end = (end[0] - tip_offset, end[1] + tip_offset)
+                case "topRight":
+                    end = (end[0] + tip_offset, end[1] + tip_offset)
+                case "bottomLeft":
+                    end = (end[0] - tip_offset, end[1] - tip_offset)
+                case "bottomRight":
+                    end = (end[0] + tip_offset, end[1] - tip_offset)
+
+        if segmented and isinstance(boxB, LogicBox):
+            # need another type check to appease mypy
+            if (
+                boxB.xLeft is None
+                or boxB.xCenter is None
+                or boxB.xRight is None
+                or boxB.yTop is None
+                or boxB.yCenter is None
+                or boxB.yBottom is None
+            ):
+                raise ValueError(
+                    "boxB LogicBox layout is not initialized before accessing coordinates."
+                )
+            if boxA.yCenter == boxB.yCenter:
+                path = [start, end]
+            elif boxA.yCenter < boxB.yCenter:
+                if boxA.xCenter == boxB.xCenter:
+                    path = [start, end]
+                else:
+                    midY = (boxA.yTop + boxB.yBottom) / 2
+                    path = [start, (start[0], midY), (end[0], midY), end]
             else:
-                Ax, Ay =  boxA.x_center, boxA.yTop + butt_offset
-                Bx = boxB.x_center
-                By = (boxB.yBottom + boxA.yTop)/2
-                Cx, Cy = Bx, boxB.yBottom - tip_offset
-                path = [(Ax, Ay), (Bx, By), (Cx, Cy)]
-        # third case, boxA is above boxB
-        elif boxA.y_center > boxB.y_center:
-            # same column
-            if boxA.x_center == boxB.x_center:
-                Ax, Ay = boxA.x_center, boxA.yBottom - butt_offset
-                Bx, By = boxB.x_center, boxB.yTop + tip_offset
-                path = [(Ax, Ay), (Bx, By)]
-            # boxes are offset in the x-axis
+                if boxA.xCenter == boxB.xCenter:
+                    path = [start, end]
+                else:
+                    midY = (boxA.yBottom + boxB.yTop) / 2
+                    path = [start, (start[0], midY), (end[0], midY), end]
+        else:
+            path = [start, end]
+
+        arrow = ArrowETC(
+            path=path,
+            arrow_head=arrow_head,
+            arrow_width=arrow_width,
+            ec=ec,
+            fc=fc,
+            lw=lw,
+        )
+        self.add_arrow(arrow)
+
+    def add_bezier_connection(
+        self,
+        boxA: LogicBox,
+        boxB: Union[LogicBox, Tuple[float, float]],
+        style: Literal["smooth", "elbow", "s-curve"] = "smooth",
+        control_points: Optional[list[tuple[float, float]]] = None,
+        arrow_head: bool = True,
+        arrow_width: float = 0.5,
+        fill_connection: bool = True,
+        fc: Optional[str] = None,
+        ec: Optional[str] = None,
+        lw: float = 0.7,
+        sideA: Optional[
+            Literal[
+                "left",
+                "topLeft",
+                "top",
+                "topRight",
+                "right",
+                "bottomRight",
+                "bottom",
+                "bottomLeft",
+                "center",
+            ]
+        ] = None,
+        sideB: Optional[
+            Literal[
+                "left",
+                "topLeft",
+                "top",
+                "topRight",
+                "right",
+                "bottomRight",
+                "bottom",
+                "bottomLeft",
+                "center",
+            ]
+        ] = None,
+        butt_offset: float = 0,
+        tip_offset: float = 0,
+        n_bezier: int = 600,
+    ) -> None:
+        """
+        Draw a curved Bezier arrow connection between two LogicBoxes or from a LogicBox to a fixed point.
+
+        The arrow path may be automatically shaped using preset styles or manually customized with control points.
+        You can specify exact exit and entry sides (edges or corners) of the boxes, and apply optional offsets to
+        avoid overlap with box borders.
+
+        Parameters
+        ----------
+        boxA : LogicBox
+            The source LogicBox from which the arrow originates.
+        boxB : LogicBox | Tuple[float, float]
+            The target LogicBox, or the exact coordinates (x, y) to which the arrow points. If you want
+            padding between the point (or LogicBox edge), update the `tip_offset` parameter.
+        style : {'smooth', 'elbow', 's-curve'}, optional
+            If `control_points` is not provided, determines the default Bezier shape:
+            - 'smooth': a gently arced curve perpendicular to the connection line
+            - 'elbow': a right-angle step shape
+            - 's-curve': a symmetric double bend for greater visual separation
+        control_points : list of (float, float), optional
+            Explicit control points for the Bezier curve. Overrides `style` if provided.
+        arrow_head : bool, optional
+            Whether to draw an arrowhead pointing at `boxB`. Default is True.
+        arrow_width : float, optional
+            Width of the arrow shaft in data units. Default is 0.5.
+        fill_connection : bool, optional
+            Whether to fill the arrow body with color. Default is True.
+        butt_offset : float, optional
+            Distance to offset the starting point of the arrow (away from `boxA`) in the
+            direction of the connection. Default is 0.
+        tip_offset : float, optional
+            Distance to offset the tip of the arrow (away from `boxB`) to avoid overlap.
+            Default is 0.
+        fc : str, optional
+            Fill color of the arrow body. If None, uses `boxB`'s face color. If 'ec', uses `boxB`'s edge color.
+        ec : str, optional
+            Edge color (outline) of the arrow. If None, uses `boxB`'s edge color. If 'fc', uses face color.
+        lw : float, optional
+            Line width of the arrow outline. Default is 0.7.
+        sideA : {'left', 'topLeft', 'right', 'topRight', 'top', 'bottomRight', 'bottom', 'bottomLeft', 'center'}, optional
+            The side or corner of `boxA` where the arrow starts. If not provided, inferred automatically.
+        sideB : {'left', 'topLeft', 'right', 'topRight', 'top', 'bottomRight', 'bottom', 'bottomLeft', 'center'}, optional
+            The side or corner of `boxB` where the arrow ends. Ignored if `boxB` is a coordinate.
+        n_bezier : int, optional
+            Number of interpolation points used to render the Bezier curve. Increase if your arrowhead looks distorted.
+            Default is 600.
+
+        Raises
+        ------
+        ValueError
+            If boxA and boxB have the same center position.
+        ValueError
+            If required box coordinates are not initialized.
+        ValueError
+            If style is unknown and control_points is not provided.
+        """
+
+        if (
+            boxA.xLeft is None
+            or boxA.xCenter is None
+            or boxA.xRight is None
+            or boxA.yTop is None
+            or boxA.yCenter is None
+            or boxA.yBottom is None
+        ):
+            raise ValueError(
+                "boxA LogicBox layout is not initialized before accessing coordinates."
+            )
+
+        if isinstance(boxB, LogicBox):
+            if (
+                boxB.xLeft is None
+                or boxB.xCenter is None
+                or boxB.xRight is None
+                or boxB.yTop is None
+                or boxB.yCenter is None
+                or boxB.yBottom is None
+            ):
+                raise ValueError(
+                    "boxB LogicBox layout is not initialized before accessing coordinates."
+                )
+
+            if fill_connection:
+                if fc is None or fc == "fc":
+                    fc = boxB.face_color
+                elif fc == "ec":
+                    fc = boxB.edge_color
+            if ec is None or ec == "ec":
+                ec = boxB.edge_color
+            elif ec == "fc":
+                ec = boxB.face_color
+
+            if boxA.xCenter == boxB.xCenter and boxA.yCenter == boxB.yCenter:
+                raise ValueError("Boxes cannot have the same position.")
+
+            dx = boxB.xCenter - boxA.xCenter
+            dy = boxB.yCenter - boxA.yCenter
+        else:
+            # boxB is a coordinate
+            xB, yB = boxB
+            dx = xB - boxA.xCenter
+            dy = yB - boxA.yCenter
+
+        theta = degrees(atan2(dy, dx))
+
+        def auto_side(theta: float, for_A: bool) -> str:
+            if -45 <= theta <= 45:
+                return "right" if for_A else "left"
+            elif 45 < theta <= 135:
+                return "top" if for_A else "bottom"
+            elif theta > 135 or theta < -135:
+                return "left" if for_A else "right"
             else:
-                Ax, Ay =  boxA.x_center, boxA.yBottom - butt_offset
-                Bx = boxA.x_center
-                By = (boxB.yTop + boxA.yBottom)/2
-                Cx, Cy = boxB.x_center, By
-                Dx, Dy = Cx, boxB.yTop + tip_offset
-                path = [(Ax, Ay), (Bx, By), (Cx, Cy), (Dx, Dy)]
+                return "bottom" if for_A else "top"
+
+        resolved_sideA = sideA or auto_side(theta, for_A=True)
+        resolved_sideB = sideB or auto_side(theta, for_A=False)
+
+        start = self._get_side_coords(boxA, resolved_sideA)
+
+        if isinstance(boxB, LogicBox):
+            end = self._get_side_coords(boxB, resolved_sideB)
+        else:
+            end = boxB  # raw coordinate
+
+        # Apply butt offset
+        if butt_offset:
+            match resolved_sideA:
+                case "left":
+                    start = (start[0] - butt_offset, start[1])
+                case "right":
+                    start = (start[0] + butt_offset, start[1])
+                case "top":
+                    start = (start[0], start[1] + butt_offset)
+                case "bottom":
+                    start = (start[0], start[1] - butt_offset)
+                case "topLeft":
+                    start = (start[0] - butt_offset, start[1] + butt_offset)
+                case "topRight":
+                    start = (start[0] + butt_offset, start[1] + butt_offset)
+                case "bottomLeft":
+                    start = (start[0] - butt_offset, start[1] - butt_offset)
+                case "bottomRight":
+                    start = (start[0] + butt_offset, start[1] - butt_offset)
+
+        # Apply tip offset
+        if tip_offset:
+            match resolved_sideB:
+                case "left":
+                    end = (end[0] - tip_offset, end[1])
+                case "right":
+                    end = (end[0] + tip_offset, end[1])
+                case "top":
+                    end = (end[0], end[1] + tip_offset)
+                case "bottom":
+                    end = (end[0], end[1] - tip_offset)
+                case "topLeft":
+                    end = (end[0] - tip_offset, end[1] + tip_offset)
+                case "topRight":
+                    end = (end[0] + tip_offset, end[1] + tip_offset)
+                case "bottomLeft":
+                    end = (end[0] - tip_offset, end[1] - tip_offset)
+                case "bottomRight":
+                    end = (end[0] + tip_offset, end[1] - tip_offset)
+
+        if control_points is not None:
+            path = [start] + control_points + [end]
         else:
-            raise ValueError("Boxes must be aligned horizontally or vertically to create a connection.")
-                
-        # create arrow object and 
-        arrow = ArrowETC(path=path, arrow_head=arrow_head, arrow_width=arrow_width)
-        x = arrow.x_vertices
-        y = arrow.y_vertices
-        self.ax.plot(x, y, color=ec, lw=lw)
-        # fill arrow if desired
-        if fill_connection:
-            self.ax.fill(x, y, color=fc)
-            
+            match style:
+                case "smooth":
+                    cx = (start[0] + end[0]) / 2
+                    cy = (start[1] + end[1]) / 2
+                    normal = (-dy, dx)
+                    mag = (dx**2 + dy**2) ** 0.5 or 1e-6
+                    offset = 0.2 * mag
+                    ctrl = (
+                        cx + normal[0] / mag * offset,
+                        cy + normal[1] / mag * offset,
+                    )
+                    path = [start, ctrl, end]
+                case "elbow":
+                    ctrl1 = (end[0], start[1])
+                    ctrl2 = (end[0], end[1])
+                    path = [start, ctrl1, ctrl2]
+                case "s-curve":
+                    d = 0.3 * (dx**2 + dy**2) ** 0.5
+                    ctrl1 = (
+                        (2 * start[0] + end[0]) / 3,
+                        (2 * start[1] + end[1]) / 3 - d,
+                    )
+                    ctrl2 = (
+                        (start[0] + 2 * end[0]) / 3,
+                        (start[1] + 2 * end[1]) / 3 + d,
+                    )
+                    path = [start, ctrl1, ctrl2, end]
+                case _:
+                    raise ValueError(f"Unknown style '{style}'")
+
+        arrow = ArrowETC(
+            path=path,
+            arrow_head=arrow_head,
+            arrow_width=arrow_width,
+            bezier=True,
+            bezier_n=n_bezier,
+            fc=fc,
+            ec=ec,
+            lw=lw,
+        )
+        self.add_arrow(arrow)
+
     def make_title(
-        self, 
-        pos: Literal['left', 'center', 'right'] = 'left', 
-        consider_box_x: bool = True, 
-        new_title: Optional[str] = None
+        self,
+        pos: Literal["left", "center", "right"] = "left",
+        consider_box_x: bool = True,
+        new_title: Optional[str] = None,
     ) -> None:
         """
         Place a title on the LogicTree figure.
@@ -678,50 +1360,75 @@ class LogicTree:
         Raises
         ------
         ValueError
-            If `pos` is not one of the accepted options.
+            If `pos` is not one of ['left', 'center', 'right'].
+        ValueError
+            If `self.title` is None when attempting to create the title.
+        ValueError
+            If any LogicBox in the layout is missing `xLeft` or `xRight` coordinates (if `consider_box_x=True`).
+
         """
         if new_title is not None:
             self.title = new_title
-        
+
         # if we are to ignore consider_box_x, use xlims to find the horizontal placement of title
         if not consider_box_x:
-            if pos == 'left':
-                ha = 'left'
+            if pos == "left":
+                ha = "left"
                 x = self.xlims[0]
-            elif pos == 'center':
-                ha = 'center'
-                x = (self.xlims[1] + self.xlims[0])/2
-            elif pos == 'right':
-                ha = 'right'
+            elif pos == "center":
+                ha = "center"
+                x = (self.xlims[1] + self.xlims[0]) / 2
+            elif pos == "right":
+                ha = "right"
                 x = self.xlims[1]
             else:
                 raise ValueError("pos must be one of ['left', 'center', 'right']")
-        
+
         # if we are to consider_box_x
         else:
-            xFarLeft = float('inf')
-            xFarRight = float('-inf')
+            xFarLeft = float("inf")
+            xFarRight = float("-inf")
             for box in self.boxes:
-                if self.boxes[box].xLeft < xFarLeft:
-                    xFarLeft = self.boxes[box].xLeft
-                if self.boxes[box].xRight > xFarRight:
-                    xFarRight = self.boxes[box].xRight
-            if pos == 'left':
-                ha = 'left'
+                x_left = self.boxes[box].xLeft
+                x_right = self.boxes[box].xRight
+
+                if x_left is None or x_right is None:
+                    raise ValueError(
+                        f"LogicBox '{box}' layout not initialized: xLeft or xRight is None."
+                    )
+
+                if x_left < xFarLeft:
+                    xFarLeft = x_left
+                if x_right > xFarRight:
+                    xFarRight = x_right
+            if pos == "left":
+                ha = "left"
                 x = xFarLeft
-            elif pos == 'right':
-                ha = 'right'
+            elif pos == "right":
+                ha = "right"
                 x = xFarRight
-            elif pos == 'center':
-                ha = 'center'
-                x = (xFarRight + xFarLeft)/2
+            elif pos == "center":
+                ha = "center"
+                x = (xFarRight + xFarLeft) / 2
             else:
                 raise ValueError("pos must be one of ['left', 'center', 'right']")
-        
+
         # finally make the title
-        self.ax.text(x=x, y=self.ylims[1], s=self.title, va='top', ha=ha, fontdict=self.title_font)
-                
-    def save_as_png(self, file_name: str, dpi: int = 800, content_padding: float = 0.0) -> None:
+        if self.title is None:
+            raise ValueError("LogicTree.title is None. Please provide a title.")
+
+        self.ax.text(
+            x=x,
+            y=self.ylims[1],
+            s=self.title,
+            va="top",
+            ha=ha,
+            fontdict=self.title_font,
+        )
+
+    def save_as_png(
+        self, file_name: str, dpi: int = 800, content_padding: float = 0.0
+    ) -> None:
         """
         Save the LogicTree diagram as a PNG file.
 
@@ -735,8 +1442,10 @@ class LogicTree:
             The padding in inches to place around the content. This can be helpful
             to prevent your boxes from touching the edge of the figures.
         """
-        self.ax.set_aspect('equal')
-        # self.fig.subplots_adjust(right=28)
-        self.fig.savefig(file_name, dpi=dpi, bbox_inches='tight', pad_inches=content_padding)
+        self.ax.set_aspect("equal")
+        self.fig.savefig(
+            file_name, dpi=dpi, bbox_inches="tight", pad_inches=content_padding
+        )
+
 
 __all__ = ["LogicTree"]
diff --git a/logictree/__init__.py b/logictree/__init__.py
index a8d3b83..81da801 100644
--- a/logictree/__init__.py
+++ b/logictree/__init__.py
@@ -3,7 +3,6 @@ LogicTreeETC: Flexible logic trees and multi-segment arrows with vertex-level co
 
 Modules:
 - LogicTree: Create and connect labeled decision boxes.
-- ArrowETC: Multi-segment arrows with explicit vertices.
 - LogicBoxETC: Render styled, rotatable text boxes.
 
 See the documentation for details and examples.
@@ -15,15 +14,14 @@ __email__ = "carret1268@gmail.com"
 __license__ = "CC0 1.0 Universal"
 
 from .LogicTreeETC import LogicTree
-from .ArrowETC import ArrowETC
 from .LogicBoxETC import LogicBox
 
 __all__ = [
     "LogicTree",
-    "ArrowETC",
     "LogicBox",
 ]
 
 import logging
+
 logger = logging.getLogger(__name__)
 logger.addHandler(logging.NullHandler())
diff --git a/pyproject.toml b/pyproject.toml
index db25db5..47bbaec 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -5,21 +5,20 @@ build-backend = "setuptools.build_meta"
 [project]
 name = "LogicTreeETC"
 version = "0.1.0"
-description = "A package for logic trees with ETC features"
+description = "A package for easily creating publication ready logic trees"
 authors = [
     { name="E. Tyler Carr", email="carret1268@gmail.com" }
 ]
 readme = "README.md"
 license = { file = "LICENSE" }
-requires-python = ">=3.8"
+requires-python = ">=3.10"
 dependencies = [
     "matplotlib",
-    "numpy"
+    "numpy",
+    "arrowetc",
 ]
 classifiers = [
     "Programming Language :: Python :: 3",
-    "Programming Language :: Python :: 3.8",
-    "Programming Language :: Python :: 3.9",
     "Programming Language :: Python :: 3.10",
     "License :: CC0 1.0 Universal (CC0 1.0) Public Domain Dedication",
     "Operating System :: OS Independent",
@@ -35,4 +34,16 @@ include-package-data = true
 where = ["."]
 
 [tool.setuptools.package-data]
-"logictree" = ["fonts/*.ttf"]
\ No newline at end of file
+"logictree" = ["fonts/*.ttf"]
+
+[tool.ruff]
+lint.ignore = ["E501"]
+
+[tool.mypy]
+python_version = "3.10"  
+ignore_missing_imports = true
+strict_optional = true
+disallow_untyped_defs = true
+disallow_incomplete_defs = true
+warn_unused_ignores = true
+show_error_codes = true
diff --git a/scripts/check_version_and_build_docs.sh b/scripts/check_version_and_build_docs.sh
new file mode 100644
index 0000000..4b2bc68
--- /dev/null
+++ b/scripts/check_version_and_build_docs.sh
@@ -0,0 +1,19 @@
+#!/usr/bin/env bash
+set -e
+
+# Extract version from pyproject.toml
+VERSION=$(grep -Po '(?<=^version = ")[^"]+' pyproject.toml)
+echo "Detected version in pyproject.toml: $VERSION"
+
+# Update docs/conf.py if needed
+CURRENT_CONF_VERSION=$(grep -Po '(?<=^release = ")[^"]+' docs/conf.py || echo "none")
+if [ "$CURRENT_CONF_VERSION" != "$VERSION" ]; then
+  echo "Updating docs/conf.py version from $CURRENT_CONF_VERSION to $VERSION"
+  sed -i "s/^release = .*/release = \"$VERSION\"/" docs/conf.py
+else
+  echo "docs/conf.py already has the correct version."
+fi
+
+# Build docs
+cd docs
+make html
diff --git a/tests/test_logic_box.py b/tests/test_logic_box.py
new file mode 100644
index 0000000..83d800d
--- /dev/null
+++ b/tests/test_logic_box.py
@@ -0,0 +1,108 @@
+import sys
+import os
+
+from matplotlib.patches import BoxStyle
+import pytest
+
+project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
+if project_root not in sys.path:
+    sys.path.insert(0, project_root)
+
+from logictree import LogicBox  # noqa: E402
+
+
+def test_logic_box_initialization_defaults():
+    font_dict = {"fontsize": 12, "color": "white"}
+    box = LogicBox(
+        xpos=10,
+        ypos=20,
+        text="Test",
+        box_name="box1",
+        bbox_fc="black",
+        bbox_ec="white",
+        font_dict=font_dict,
+    )
+    assert box.x == 10
+    assert box.y == 20
+    assert box.text == "Test"
+    assert box.name == "box1"
+    assert box.face_color == "black"
+    assert box.edge_color == "white"
+    assert box.font_dict == font_dict
+    assert box.va == "center"
+    assert box.ha == "left"
+    assert box.lw == 1.6
+    assert box.angle == 0.0
+    assert box.style["boxstyle"].__class__.__name__ == "Square"
+    assert box.xLeft is None
+    assert box.xRight is None
+    assert box.yBottom is None
+    assert box.yTop is None
+    assert box.width is None
+    assert box.height is None
+    assert box.xCenter is None
+    assert box.yCenter is None
+
+
+def test_logic_box_initialization_with_style():
+    font_dict = {"fontsize": 14}
+    style = BoxStyle("Round", pad=0.2)
+    box = LogicBox(
+        xpos=5,
+        ypos=5,
+        text="Styled",
+        box_name="box2",
+        bbox_fc="blue",
+        bbox_ec="red",
+        font_dict=font_dict,
+        bbox_style=style,
+        lw=2.5,
+        va="top",
+        ha="right",
+        angle=15,
+    )
+    assert box.va == "top"
+    assert box.ha == "right"
+    assert box.lw == 2.5
+    assert box.angle == 15
+    assert box.style["boxstyle"].__class__.__name__ == "Round"
+
+
+def test_logic_box_invalid_alignment_raises():
+    with pytest.raises(ValueError, match="Invalid va: middle"):
+        LogicBox(
+            xpos=0,
+            ypos=0,
+            text="Bad VA",
+            box_name="box3",
+            bbox_fc="black",
+            bbox_ec="black",
+            font_dict={},
+            va="middle",
+        )
+
+    with pytest.raises(ValueError, match="Invalid ha: mid"):
+        LogicBox(
+            xpos=0,
+            ypos=0,
+            text="Bad HA",
+            box_name="box4",
+            bbox_fc="black",
+            bbox_ec="black",
+            font_dict={},
+            ha="mid",
+        )
+
+
+def test_logic_box_repr():
+    box = LogicBox(
+        xpos=100,
+        ypos=200,
+        text="Hello",
+        box_name="title",
+        bbox_fc="white",
+        bbox_ec="black",
+        font_dict={},
+    )
+    rep = repr(box)
+    assert rep == "<LogicBox(name='title', text='Hello', x=100, y=200)>"
diff --git a/tests/test_logic_tree.py b/tests/test_logic_tree.py
index e69de29..f13f0ff 100644
--- a/tests/test_logic_tree.py
+++ b/tests/test_logic_tree.py
@@ -0,0 +1,256 @@
+from numpy import allclose
+import matplotlib
+import pytest
+from unittest.mock import MagicMock
+
+from logictree.LogicTreeETC import LogicTree
+from logictree.LogicBoxETC import LogicBox
+
+matplotlib.use("Agg")
+
+
+def create_logic_box(tree, name, x, y, **kwargs):
+    tree.add_box(
+        xpos=x,
+        ypos=y,
+        text=name,
+        box_name=name,
+        bbox_fc="black",
+        bbox_ec="white",
+        ha="center",
+        **kwargs,
+    )
+    return tree.boxes[name]
+
+
+def test_logic_tree_init():
+    tree = LogicTree()
+    assert tree.title is None
+    assert tree.xlims == (0, 100)
+    assert tree.ylims == (0, 100)
+    assert tree.title_font["fontname"] == "Times New Roman"
+    assert tree.font_dict["fontsize"] == 15
+
+    tree = LogicTree(
+        fig_size=(5, 5),
+        xlims=(0, 10),
+        ylims=(-10, 10),
+        fig_fc="white",
+        title="Test Tree",
+        font_dict={"fontname": "Calibri", "fontsize": 20, "color": "black"},
+        font_dict_title={"fontname": "Comic Sans", "fontsize": 24, "color": "magenta"},
+        text_color=None,
+        title_color=None,
+    )
+    assert tree.title == "Test Tree"
+    assert tree.title_font["fontname"] == "Comic Sans"
+
+    tree = LogicTree(
+        font_dict={"fontname": "Calibri", "fontsize": 20, "color": "black"},
+        font_dict_title={"fontname": "Comic Sans", "fontsize": 24, "color": "magenta"},
+        text_color="green",
+        title_color="cyan",
+    )
+    assert tree.title_font["color"] == "cyan"
+    assert tree.font_dict["color"] == "green"
+
+
+def test_get_pathsForBi_left_then_right():
+    tree = LogicTree()
+    tree.add_box(0, 0, "", "boxA", "black", "white")
+    tree.add_box(0, 10, "", "boxB", "black", "white")
+
+    with pytest.raises(ValueError):
+        tree._get_pathsForBi_left_then_right(
+            5,
+            10,
+            tree.boxes["boxA"],
+            LogicBox(0, 10, "fail", "fail", "white", "black", {}),
+            0,
+        )
+    with pytest.raises(ValueError):
+        tree._get_pathsForBi_left_then_right(
+            5,
+            10,
+            LogicBox(0, 10, "fail", "fail", "white", "black", {}),
+            tree.boxes["boxB"],
+            0,
+        )
+
+    expected = (
+        [
+            (5, 10),
+            (-16.057347670250895, 10),
+            (-16.057347670250895, -14.054834054834053),
+        ],
+        [
+            (5, 10),
+            (-16.057347670250895, 10),
+            (-16.057347670250895, -14.054834054834053),
+        ],
+    )
+    actual = tree._get_pathsForBi_left_then_right(
+        5, 10, tree.boxes["boxA"], tree.boxes["boxB"], 0
+    )
+    assert all(allclose(a, b) for a, b in zip(actual[0], expected[0]))
+    assert all(allclose(a, b) for a, b in zip(actual[1], expected[1]))
+
+
+def test_add_box():
+    tree = LogicTree()
+    tree.add_box(0, 2, "boxAText", "boxA", "black", "white")
+    boxA = tree.boxes["boxA"]
+    assert allclose([boxA.xRight], [1.8], 0.01)
+    assert boxA.text == "boxAText"
+
+    tree.add_box(0, 2, "boxBText", "boxB", "black", "white", va="bottom", ha="left")
+    boxB = tree.boxes["boxB"]
+    print(boxB.xLeft)
+    assert allclose([boxB.xLeft], [-1.8], 0.01)
+
+    tree.add_box(
+        0,
+        2,
+        "boxCText",
+        "boxC",
+        "black",
+        "white",
+        use_tex_rendering=True,
+        ul=True,
+        ul_depth_width=(2, 3),
+    )
+    assert tree.boxes["boxC"].name == "boxC"
+
+    with pytest.raises(ValueError):
+        tree.add_box(10, 20, "boxDText", "boxC", "green", "cyan")
+
+
+def test_add_connection_biSplit():
+    tree = LogicTree()
+    # downward pointing tree
+    tree.add_box(5, 5, "boxAText", "boxA", "black", "white")
+    tree.add_box(0, 0, "boxBText", "boxB", "black", "white")
+    tree.add_box(10, 0, "boxCText", "boxC", "black", "white")
+
+    # upward pointing tree
+    tree.add_box(0, 10, "boxUpB", "boxUpB", "black", "white")
+    tree.add_box(10, 10, "boxUpC", "boxUpC", "black", "white")
+    tree.add_box(5, 5, "boxUpA", "boxUpA", "black", "white")
+
+    tree.ax = MagicMock()
+
+    # Downward connection
+    tree.add_connection_biSplit(
+        tree.boxes["boxA"],
+        tree.boxes["boxB"],
+        tree.boxes["boxC"],
+        fill_connection=True,
+        fc_A="ec",
+        ec_B="fc",
+        ec_C="fc",
+    )
+
+    # Upward connection
+    tree.add_connection_biSplit(
+        tree.boxes["boxUpA"],
+        tree.boxes["boxUpC"],
+        tree.boxes["boxUpB"],
+        arrow_head=False,
+        fill_connection=False,
+        fc_A="black",
+        ec_B="white",
+        ec_C="white",
+    )
+
+    # Confirm drawing calls were made
+    assert tree.ax.plot.call_count >= 5
+    assert tree.ax.fill.call_count >= 2
+
+    for args, kwargs in tree.ax.fill.call_args_list:
+        assert "color" in kwargs
+        assert kwargs["color"] in {"black", "white", None}
+
+    # raise errors for uninitialized boxes
+    with pytest.raises(ValueError):
+        tree.add_connection_biSplit(
+            LogicBox(0, 10, "fail", "fail", "white", "black", {}),
+            tree.boxes["boxB"],
+            tree.boxes["boxC"],
+        )
+    with pytest.raises(ValueError):
+        tree.add_connection_biSplit(
+            tree.boxes["boxA"],
+            LogicBox(0, 10, "fail", "fail", "white", "black", {}),
+            tree.boxes["boxC"],
+        )
+    with pytest.raises(ValueError):
+        tree.add_connection_biSplit(
+            tree.boxes["boxA"],
+            tree.boxes["boxB"],
+            LogicBox(0, 10, "fail", "fail", "white", "black", {}),
+        )
+
+
+def test_add_connection():
+    tree = LogicTree()
+    tree.add_box(0, 0, "boxAText", "boxA", "black", "white")
+    tree.add_box(0, 5, "boxBText", "boxB", "black", "white")
+    tree.add_box(5, 0, "boxCRight", "boxCR", "black", "white")
+    tree.add_box(5, 10, "boxD", "boxD", "black", "white")
+
+    tree.ax = MagicMock()
+    tree.add_connection(
+        tree.boxes["boxA"],
+        tree.boxes["boxB"],
+        arrow_head=True,
+        fill_connection=True,
+        fc="ec",
+        ec="fc",
+        lw=1.0,
+    )
+    assert tree.ax.plot.called
+    assert tree.ax.fill.called
+
+    tree.add_connection(tree.boxes["boxCR"], tree.boxes["boxA"])
+    assert tree.ax.plot.call_count >= 2
+
+    tree.add_connection(tree.boxes["boxA"], tree.boxes["boxD"])
+    assert tree.ax.plot.call_count >= 3
+
+    bad_box = LogicBox(0, 0, "fail", "fail", "white", "black", {})
+    with pytest.raises(ValueError, match="boxA LogicBox layout is not initialized"):
+        tree.add_connection(bad_box, tree.boxes["boxB"])
+
+    with pytest.raises(ValueError, match="boxB LogicBox layout is not initialized"):
+        tree.add_connection(tree.boxes["boxA"], bad_box)
+
+
+def test_save_as_png(tmp_path):
+    tree = LogicTree(title="Arrow Test")
+    a = create_logic_box(tree, "A", 10, 20)
+    b = create_logic_box(tree, "B", 10, 10)
+    tree.add_connection(a, b)
+    output = tmp_path / "out.png"
+    tree.save_as_png(str(output))
+
+    assert output.exists()
+
+
+def test_make_title(tmp_path):
+    tree = LogicTree(title="BiSplit Test")
+    a = create_logic_box(tree, "A", 20, 30)
+    b = create_logic_box(tree, "B", 10, 10)
+    c = create_logic_box(tree, "C", 30, 10)
+    tree.add_connection_biSplit(a, b, c)
+    tree.make_title(pos="center", new_title="New Title")
+    tree.make_title(pos="center", new_title="New Title", consider_box_x=False)
+    output = tmp_path / "tree.png"
+    tree.save_as_png(str(output))
+    assert output.exists()
+
+    tree = LogicTree()
+    with pytest.raises(ValueError, match="LogicTree.title is None"):
+        tree.make_title()
+
+    with pytest.raises(ValueError, match="pos must be one of"):
+        tree.make_title(pos="invalid", new_title="New Title 2")
